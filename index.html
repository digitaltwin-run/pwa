<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Digital Twin IDE</title>
    <link rel="stylesheet" href="css/styles.css"/>
    <link rel="manifest" href="manifest.json"/>
    <link rel="icon" href="assets/icons/icon-192.png"/>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f0f1;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        /* Pasek narzƒôdzi na g√≥rze */
        .toolbar {
            background: #2c3e50;
            padding: 10px;
            text-align: right;
            color: white;
            font-size: 14px;
            border-bottom: 1px solid #34495e;
        }

        .toolbar button {
            margin: 0 5px;
            padding: 6px 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }

        /* G≈Ç√≥wny kontener ‚Äì flex z trzema kolumnami */
        .container {
            display: flex;
            flex: 1; /* Wype≈Çnia ca≈ÇƒÖ dostƒôpnƒÖ wysoko≈õƒá po toolbarze */
            height: calc(100vh - 50px); /* R√≥≈ºnica dla toolbara */
            overflow: hidden;
        }

        /* Boczne panele ‚Äì sta≈Ça szeroko≈õƒá */
        .sidebar {
            width: 260px;
            background: #2c3e50;
            color: white;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
        }

        .sidebar h3 {
            margin: 0;
            padding: 15px;
            font-size: 16px;
            border-bottom: 1px solid #34495e;
            background: #34495e;
        }

        .component-list {
            padding: 10px;
            flex: 1;
        }

        .component-item {
            padding: 10px;
            background: #3498db;
            margin: 6px 0;
            border-radius: 6px;
            cursor: grab;
            user-select: none;
            font-size: 14px;
            text-align: center;
            transition: background 0.2s;
        }

        .component-item:hover {
            background: #2980b9;
        }

        /* Plansza centralna ‚Äì zajmuje ca≈ÇƒÖ resztƒô */
        .workspace {
            flex: 1;
            background: #ecf0f1;
            border-left: 1px solid #bdc3c7;
            border-right: 1px solid #bdc3c7;
            overflow: auto;
            position: relative;
        }

        #svg-canvas {
            width: 100%;
            height: 100%;
            min-height: 100%;
            background-color: #fff;
        }

        #canvas {
            width: 100%;
            height: 100%;
            overflow: visible;
            cursor: default;
            background: white;
        }

        /* Panel w≈Ça≈õciwo≈õci ‚Äì prawy sidebar */
        #property-editor {
            padding: 10px;
            color: #333;
            font-size: 14px;
        }

        #property-editor label {
            display: block;
            margin-top: 12px;
            font-weight: 600;
            color: #ecf0f1;
            font-size: 13px;
        }

        #property-editor input {
            width: 100%;
            padding: 6px;
            margin-top: 4px;
            border: 1px solid #34495e;
            border-radius: 4px;
            font-size: 13px;
        }

        #property-editor input[type="color"] {
            height: 30px;
        }

        #property-editor button {
            margin-top: 15px;
            padding: 8px;
            background: #e74c3c;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: 100%;
        }

        /* Panel symulacji ‚Äì na dole */
        .simulation-panel {
            background: #1a1a1a;
            color: #fff;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            border-top: 1px solid #333;
        }

        .simulation-panel h3 {
            margin: 0 0 10px 0;
            font-size: 15px;
        }

        .simulation-panel p {
            margin: 5px 0;
            font-size: 13px;
            color: #ccc;
        }
        .component-button {
            display: flex;
            align-items: center;
            width: 100%;
            padding: 8px 10px;
            margin: 6px 0;
            background: #3498db;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: grab;
            user-select: none;
            font-size: 14px;
            transition: background 0.2s, transform 0.1s;
            gap: 12px;
            text-align: left;
        }

        .component-button:hover {
            background: #2980b9;
            transform: translateY(-1px);
        }

        .component-button:active {
            transform: translateY(0);
        }

        .component-button svg {
            flex-shrink: 0;
            width: 36px;
            height: 36px;
            border: 1px solid #fff;
            border-radius: 6px;
            background: white;
            padding: 2px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }

        .component-button span {
            font-size: 14px;
            font-weight: 500;
            flex: 1;
            margin-left: 4px;
        }
    </style>
</head>
<body>

<!-- Przyciski narzƒôdzi -->
<div class="toolbar">
    <button onclick="exportProject()" style="background: #27ae60; color: white;">üì§ Eksportuj (.dtwin)</button>
    <button onclick="importProject()" style="background: #3498db; color: white;">üì• Importuj (.dtwin)</button>
    <button onclick="exportAsPNG()" style="background: #e67e22; color: white;">üñºÔ∏è PNG</button>
    <button onclick="exportAsSVG()" style="background: #3498db; color: white;">üü© SVG</button>
    <button onclick="toggleConnectionMode()" style="background: #8e44ad; color: white;">üîó ≈ÅƒÖcz komponenty</button>
</div>

<!-- Panel symulacji -->
<div class="simulation-panel">
    <h3>üìä Symulacja Danych</h3>
    <button onclick="startSimulation()" style="background: #27ae60; color: white;">‚ñ∂Ô∏è Start</button>
    <button onclick="stopSimulation()" style="background: #e74c3c; color: white;">‚è∏Ô∏è Stop</button>
    <div id="simulation-list" style="margin-top: 10px; max-height: 150px; overflow-y: auto;">
        <p><i>Brak komponent√≥w do symulacji</i></p>
    </div>
</div>

<!-- G≈Ç√≥wny uk≈Çad -->
<div class="container">
    <!-- Lewa kolumna: Komponenty -->
    <aside class="sidebar left">
        <h3>üîß Komponenty</h3>
        <div class="component-list" id="component-library">
            <!-- Komponenty bƒôdƒÖ dodawane dynamicznie z ikonami -->
        </div>
    </aside>

    <!-- ≈örodkowa: Plansza -->
    <div class="workspace" id="workspace">
        <svg id="svg-canvas" xmlns="http://www.w3.org/2000/svg">
            <!-- Definicje: siatka i strza≈Çka -->
            <defs>
                <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6"
                        orient="auto-start-reverse">
                    <path d="M 0 0 L 10 5 L 0 10 z" fill="#2c3e50"/>
                </marker>
                <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                    <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#ddd" stroke-width="0.5"/>
                </pattern>
            </defs>
            <rect width="100%" height="100%" fill="url(#grid)"/>
            <!-- Komponenty i linie bƒôdƒÖ dodawane tutaj -->
        </svg>
    </main>

    <!-- Prawa: W≈Ça≈õciwo≈õci -->
    <aside class="sidebar right">
        <h3>‚öôÔ∏è W≈Ça≈õciwo≈õci</h3>
        <div id="properties-panel">
            <p>Wybierz komponent, aby edytowaƒá.</p>
        </div>
    </aside>
</div>

<script>
    // Lista komponent√≥w ‚Äì ≈õcie≈ºka, nazwa, opcjonalnie ikona (je≈õli inna)
    const COMPONENTS = [
        { svg: "components/motor.svg", name: "Silnik", id: "motor" },
        { svg: "components/led.svg", name: "Diody LED", id: "led" },
        { svg: "components/switch.svg", name: "Prze≈ÇƒÖcznik", id: "switch" },
        { svg: "components/relay.svg", name: "Przeka≈∫nik", id: "relay" },
        { svg: "components/button.svg", name: "Przycisk", id: "button" },
        { svg: "components/knob.svg", name: "Pokrƒôt≈Ço", id: "knob" },
        { svg: "components/slider.svg", name: "Suwak", id: "slider" },
        { svg: "components/sensor.svg", name: "Czujnik temperatury", id: "temp-sensor" },
        { svg: "components/display.svg", name: "Wy≈õwietlacz", id: "display" },
    ];

    // Mapa przechowujƒÖca instancje komponent√≥w
    const components = new Map();
    let componentCounter = 0;
    let isConnectionMode = false;
    let connectionStart = null;
    let selectedComponent = null;
    let simulationInterval = null;

    // Pobierz kontener SVG
    const svgCanvas = document.getElementById('svg-canvas');
    const workspace = document.getElementById('workspace');

    // Inicjalizacja rozmiar√≥w SVG
    function updateSvgSize() {
        const rect = workspace.getBoundingClientRect();
        svgCanvas.setAttribute('width', rect.width);
        svgCanvas.setAttribute('height', rect.height);
        svgCanvas.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
    }

    // Aktualizuj rozmiar przy zmianie okna
    window.addEventListener('resize', updateSvgSize);
    updateSvgSize();

    function formatLabel(key) {
        return key
            .replace(/([A-Z])/g, " $1")
            .replace(/^./, s => s.toUpperCase())
            .replace(/([a-z])([A-Z])/g, '$1 $2')
            .replace(/([A-Z])([A-Z][a-z])/g, '$1 $2');
    }

    // --- OBS≈ÅUGA PRZECIƒÑGANIA KOMPONENT√ìW ---
    document.getElementById("component-library").addEventListener("dragstart", (e) => {
        const target = e.target.closest(".component-item");
        if (target) {
            e.dataTransfer.setData("text/plain", target.dataset.svg);
        }
    });

    svgCanvas.addEventListener("dragover", (e) => {
        e.preventDefault();
        e.dataTransfer.dropEffect = 'copy';
        svgCanvas.classList.add('drag-over');
    });

    svgCanvas.addEventListener('dragleave', () => {
        svgCanvas.classList.remove('drag-over');
    });

    svgCanvas.addEventListener('drop', async (e) => {
        e.preventDefault();
        svgCanvas.classList.remove('drag-over');

        const svgUrl = e.dataTransfer.getData("text/plain");
        if (!svgUrl) {
            console.error("Brak danych SVG podczas upuszczenia");
            return;
        }

        const canvasX = e.offsetX;
        const canvasY = e.offsetY;

        try {
            const response = await fetch(svgUrl);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const svgText = await response.text();
            if (!svgText || !svgText.trim().startsWith('<svg') && !svgText.trim().startsWith('<?xml')) {
                throw new Error("Nieprawid≈Çowy format SVG");
            }

            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, "image/svg+xml");

            // Sprawd≈∫ b≈Çƒôdy parsowania
            const parserError = svgDoc.querySelector("parsererror");
            if (parserError) {
                throw new Error("B≈ÇƒÖd parsowania SVG");
            }

            const svgElement = svgDoc.documentElement;
            if (!svgElement || svgElement.nodeName !== 'svg') {
                throw new Error("Nie znaleziono elementu SVG");
            }

            // Generuj nowe ID
            const componentId = `comp-${componentCounter++}`;
            svgElement.setAttribute("data-id", componentId);
            svgElement.setAttribute("data-svg-url", svgUrl);
            svgElement.setAttribute("class", "draggable-component");
            svgElement.setAttribute("style", "cursor: move;");

            // Pobierz lub utw√≥rz metadane
            let metadataNode = svgElement.querySelector("metadata");
            let metadata = {parameters: {}};

            if (metadataNode) {
                try {
                    const metadataContent = metadataNode.textContent.trim();
                    if (metadataContent) {
                        metadata = JSON.parse(metadataContent);
                    }
                } catch (e) {
                    console.warn("Niepoprawne metadane w oryginalnym SVG:", e);
                }
            } else {
                // Utw√≥rz nowe <metadata>, je≈õli nie istnieje
                metadataNode = document.createElementNS("http://www.w3.org/2000/svg", "metadata");
                svgElement.prepend(metadataNode);
            }

            // Dodaj lub zaktualizuj pozycjƒô w metadanych
            metadata.position = {x: canvasX, y: canvasY};
            metadata.id = metadata.id || componentId; // Zachowaj ID z pliku lub nadaj nowe
            metadata.instanceId = componentId; // Unikalne ID instancji
            metadata.parameters = metadata.parameters || {}; // Upewnij siƒô, ≈ºe parameters istnieje

            // Zapisz zaktualizowane metadane
            metadataNode.textContent = JSON.stringify(metadata, null, 2);

            // Ustaw pozycjƒô kontenera SVG
            const defaultSize = 50;
            const size = metadata.parameters.size || defaultSize;
            svgElement.setAttribute("x", canvasX - size / 2);
            svgElement.setAttribute("y", canvasY - size / 2);

            // Zdarzenia
            svgElement.addEventListener("click", (ev) => {
                ev.stopPropagation();
                if (isConnectionMode) {
                    startConnection(svgElement);
                } else {
                    selectComponent(svgElement);
                }
            });

            makeDraggable(svgElement);

            if (svgCanvas) {
                svgCanvas.appendChild(svgElement);
                // Od≈õwie≈º panel symulacji
                setTimeout(refreshSimulationList, 100);
            } else {
                console.error("Nie znaleziono kontenera SVG canvas");
            }
        } catch (err) {
            console.error("B≈ÇƒÖd ≈Çadowania SVG:", err);
            alert(`Nie uda≈Ço siƒô za≈Çadowaƒá komponentu: ${err.message}`);
        }
    });

    // --- WYB√ìR KOMPONENTU ---
    function selectComponent(el) {
        // Sprawd≈∫, czy element istnieje
        if (!el) return;

        const propertiesPanel = document.getElementById('properties-panel');
        if (!propertiesPanel) {
            console.error("Nie znaleziono panelu w≈Ça≈õciwo≈õci (properties-panel)");
            return;
        }

        // Je≈õli klikniƒôto w to samo, odznacz
        if (selectedComponent === el) {
            el.style.outline = '';
            selectedComponent = null;
            propertiesPanel.style.display = 'none';
            return;
        }

        // Usu≈Ñ zaznaczenie z poprzedniego komponentu
        if (selectedComponent) {
            selectedComponent.style.outline = '';
        }

        // Zaznacz nowy komponent
        selectedComponent = el;
        el.style.outline = '2px solid #3498db';

        // Poka≈º w≈Ça≈õciwo≈õci
        showProperties(el);
    }

    // --- EDYCJA W≈ÅA≈öCIWO≈öCI ---
    function showProperties(svgElement) {
        // Sprawd≈∫, czy element istnieje
        if (!svgElement) return;

        const propertiesPanel = document.getElementById("properties-panel");
        if (!propertiesPanel) {
            console.error("Nie znaleziono panelu w≈Ça≈õciwo≈õci (properties-panel)");
            return;
        }

        propertiesPanel.style.display = "block";
        propertiesPanel.innerHTML = "<h3>W≈Ça≈õciwo≈õci</h3>";

        // Pobierz ID komponentu
        const id = svgElement.getAttribute('data-id');
        if (!id) return;

        // Pobierz metadane
        const metadataNode = svgElement.querySelector("metadata");
        if (!metadataNode) return;

        let metadata;
        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            console.error("B≈ÇƒÖd parsowania metadanych:", e);
            return;
        }

        // Dodaj przycisk usuwania
        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "Usu≈Ñ komponent";
        deleteBtn.onclick = () => removeComponent(id);
        propertiesPanel.appendChild(deleteBtn);

        // Dodaj przycisk edycji surowych metadanych
        const editBtn = document.createElement("button");
        editBtn.textContent = "Edytuj metadane";
        editBtn.onclick = () => editMetadataRaw(id);
        propertiesPanel.appendChild(editBtn);

        // Dodaj w≈Ça≈õciwo≈õci
        if (metadata.parameters) {
            const params = metadata.parameters;
            Object.entries(params).forEach(([key, value]) => {
                const paramDiv = document.createElement("div");
                paramDiv.className = "property";

                const label = document.createElement("label");
                label.textContent = formatLabel(key) + ": ";

                let input;

                if (typeof value === 'boolean') {
                    input = document.createElement("input");
                    input.type = "checkbox";
                    input.checked = value;
                    input.onchange = (e) => updateParam(id, key, e.target.checked, 'boolean');
                } else if (typeof value === 'number') {
                    input = document.createElement("input");
                    input.type = "number";
                    input.value = value;
                    input.onchange = (e) => updateParam(id, key, parseFloat(e.target.value), 'number');
                } else if (typeof value === 'string' && key === 'color') {
                    input = document.createElement("input");
                    input.type = "color";
                    input.value = value || '#3498db';
                    input.onchange = (e) => updateParam(id, key, e.target.value, 'color');
                } else {
                    input = document.createElement("input");
                    input.type = "text";
                    input.value = value;
                    input.onchange = (e) => updateParam(id, key, e.target.value, 'string');
                }

                paramDiv.appendChild(label);
                paramDiv.appendChild(input);
                propertiesPanel.appendChild(paramDiv);
            });

            // Dodaj przycisk dodawania nowego parametru
            const addParamBtn = document.createElement("button");
            addParamBtn.textContent = "Dodaj parametr";
            addParamBtn.onclick = () => addParameter(id);
            propertiesPanel.appendChild(addParamBtn);
        }
    }

    // --- PRZECIƒÑGANIE KOMPONENT√ìW PO PLANSZY ---
    function makeDraggable(svgElement) {
        let isDragging = false;
        let offsetX, offsetY;

        svgElement.setAttribute('draggable', 'false'); // Zapobiegaj domy≈õlnemu zachowaniu przeglƒÖdarki

        svgElement.addEventListener('mousedown', startDrag);

        function startDrag(e) {
            if (e.button !== 0) return;

            const rect = svgElement.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;

            selectComponent(svgElement);

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);

            e.preventDefault();
            isDragging = true;
        }

        function onDrag(e) {
            if (!isDragging) return;

            const x = e.clientX - offsetX - workspace.getBoundingClientRect().left;
            const y = e.clientY - offsetY - workspace.getBoundingClientRect().top;

            const maxX = workspace.offsetWidth - svgElement.width.baseVal.value;
            const maxY = workspace.offsetHeight - svgElement.height.baseVal.value;

            const newX = Math.max(0, Math.min(x, maxX));
            const newY = Math.max(0, Math.min(y, maxY));

            svgElement.setAttribute('x', newX);
            svgElement.setAttribute('y', newY);

            const id = svgElement.getAttribute('data-id');
            if (id) {
                updatePosition(id, 'x', newX);
                updatePosition(id, 'y', newY);
            }

            updateConnections(id);
        }

        function stopDrag() {
            if (!isDragging) return;

            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);

            isDragging = false;
        }
    }

    // --- ≈ÅƒÑCZENIE KOMPONENT√ìW ---
    window.toggleConnectionMode = () => {
        isConnectionMode = !isConnectionMode;
        svgCanvas.style.cursor = isConnectionMode ? "crosshair" : "default";
        alert(isConnectionMode ? "üîÅ Tryb ≈ÇƒÖczenia: kliknij dwa komponenty." : "üéØ Tryb edycji.");
        if (!isConnectionMode && connectionStart) {
            connectionStart.style.outline = "";
            connectionStart = null;
        }
    };

    function startConnection(svgElement) {
        const metadataNode = svgElement.querySelector("metadata");
        if (!metadataNode) return;

        let metadata;
        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            return;
        }

        if (!metadata.position) {
            alert("Ten komponent nie jest jeszcze umieszczony na planszy.");
            return;
        }

        if (!isConnectionMode) return;

        if (!connectionStart) {
            connectionStart = svgElement;
            svgElement.style.outline = "3px dashed yellow";
        } else {
            if (connectionStart !== svgElement) {
                createConnection(connectionStart, svgElement);
            }
            connectionStart.style.outline = "";
            connectionStart = null;
        }
    }

    function createConnection(comp1, comp2) {
        const x1 = parseFloat(comp1.getAttribute("x")) + 30;
        const y1 = parseFloat(comp1.getAttribute("y")) + 30;
        const x2 = parseFloat(comp2.getAttribute("x")) + 30;
        const y2 = parseFloat(comp2.getAttribute("y")) + 30;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("stroke", "#2c3e50");
        line.setAttribute("stroke-width", "2");
        line.setAttribute("marker-end", "url(#arrow)");
        line.dataset.connection = "true";

        svgCanvas.appendChild(line);
    }

    // --- EKSPORT / IMPORT ---
    window.exportProject = () => {
        const components = [];
        const lines = [];

        svgCanvas.querySelectorAll("svg[data-id]").forEach(instance => {
            const metadataNode = instance.querySelector("metadata");
            if (!metadataNode) return;

            let metadata;
            try {
                metadata = JSON.parse(metadataNode.textContent);
            } catch (e) {
                return;
            }

            components.push({
                id: metadata.id,
                svgUrl: instance.dataset.svgUrl,
                x: parseFloat(instance.getAttribute("x")),
                y: parseFloat(instance.getAttribute("y")),
                metadata: metadata
            });
        });

        svgCanvas.querySelectorAll("line[data-connection]").forEach(line => {
            lines.push({
                x1: line.getAttribute("x1"),
                y1: line.getAttribute("y1"),
                x2: line.getAttribute("x2"),
                y2: line.getAttribute("y2")
            });
        });

        const project = {
            version: "1.1",
            createdAt: new Date().toISOString(),
            components,
            connections: lines
        };

        const blob = new Blob([JSON.stringify(project, null, 2)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `digital-twin-${new Date().toISOString().split("T")[0]}.dtwin.json`;
        a.click();
        URL.revokeObjectURL(url);
    };

    window.importProject = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".dtwin.json";

        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const content = await file.text();
                const project = JSON.parse(content);

                // Wyczy≈õƒá
                svgCanvas.innerHTML = `
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#2c3e50" />
              </marker>
              <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#ddd" stroke-width="0.5"/>
              </pattern>
            </defs>
            <rect width="100%" height="100%" fill="url(#grid)" />
          `;

                // Wczytaj komponenty
                for (const comp of project.components) {
                    try {
                        const response = await fetch(comp.svgUrl);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const svgText = await response.text();
                        if (!svgText || !svgText.trim().startsWith('<svg') && !svgText.trim().startsWith('<?xml')) {
                            throw new Error("Nieprawid≈Çowy format SVG");
                        }

                        const parser = new DOMParser();
                        const svgDoc = parser.parseFromString(svgText, "image/svg+xml");

                        // Sprawd≈∫ b≈Çƒôdy parsowania
                        const parserError = svgDoc.querySelector("parsererror");
                        if (parserError) {
                            throw new Error("B≈ÇƒÖd parsowania SVG");
                        }

                        const svgElement = svgDoc.documentElement;
                        if (!svgElement || svgElement.nodeName !== 'svg') {
                            throw new Error("Nie znaleziono elementu SVG");
                        }

                        // Generuj nowe ID
                        const componentId = `comp-${componentCounter++}`;
                        svgElement.setAttribute("data-id", componentId);
                        svgElement.setAttribute("data-svgUrl", comp.svgUrl);
                        svgElement.setAttribute("class", "draggable-component");
                        svgElement.setAttribute("style", "cursor: move;");

                        // Pobierz lub utw√≥rz metadane
                        let metadataNode = svgElement.querySelector("metadata");
                        let metadata = {parameters: {}};

                        if (metadataNode) {
                            try {
                                const metadataContent = metadataNode.textContent.trim();
                                if (metadataContent) {
                                    metadata = JSON.parse(metadataContent);
                                }
                            } catch (e) {
                                console.warn("Niepoprawne metadane w oryginalnym SVG:", e);
                            }
                        } else {
                            // Utw√≥rz nowe <metadata>, je≈õli nie istnieje
                            metadataNode = document.createElementNS("http://www.w3.org/2000/svg", "metadata");
                            svgElement.prepend(metadataNode);
                        }

                        // Dodaj lub zaktualizuj pozycjƒô w metadanych
                        metadata.position = {x: comp.x, y: comp.y};
                        metadata.id = metadata.id || componentId; // Zachowaj ID z pliku lub nadaj nowe
                        metadata.instanceId = componentId; // Unikalne ID instancji
                        metadata.parameters = metadata.parameters || {}; // Upewnij siƒô, ≈ºe parameters istnieje

                        // Zapisz zaktualizowane metadane
                        metadataNode.textContent = JSON.stringify(metadata, null, 2);

                        // Ustaw pozycjƒô kontenera SVG
                        const defaultSize = 50;
                        const size = metadata.parameters.size || defaultSize;
                        svgElement.setAttribute("x", comp.x - size / 2);
                        svgElement.setAttribute("y", comp.y - size / 2);

                        // Zdarzenia
                        svgElement.addEventListener("click", (ev) => {
                            ev.stopPropagation();
                            if (isConnectionMode) {
                                startConnection(svgElement);
                            } else {
                                selectComponent(svgElement);
                            }
                        });

                        makeDraggable(svgElement);
                        svgCanvas.appendChild(svgElement);
                    } catch (err) {
                        console.error("B≈ÇƒÖd komponentu:", err);
                    }
                }

                // Wczytaj linie
                project.connections.forEach(conn => {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", conn.x1);
                    line.setAttribute("y1", conn.y1);
                    line.setAttribute("x2", conn.x2);
                    line.setAttribute("y2", conn.y2);
                    line.setAttribute("stroke", "#2c3e50");
                    line.setAttribute("stroke-width", "2");
                    line.setAttribute("marker-end", "url(#arrow)");
                    line.dataset.connection = "true";
                    svgCanvas.appendChild(line);
                });

                setTimeout(refreshSimulationList, 500);
                alert(`Import: ${project.components.length} komponent√≥w, ${project.connections.length} po≈ÇƒÖcze≈Ñ.`);
            } catch (err) {
                alert("B≈ÇƒÖd importu!");
                console.error(err);
            }
        };

        input.click();
    };

    // --- EKSPORT JAKO OBRAZ ---
    window.exportAsPNG = () => {
        // Tymczasowo ukryj elementy interfejsu, kt√≥rych nie chcemy na zrzucie
        const uiElements = document.querySelectorAll('.toolbar, .sidebar, #properties-panel');
        const originalDisplays = [];

        // Zapisz oryginalne style i ukryj elementy interfejsu
        uiElements.forEach(el => {
            originalDisplays.push(el.style.display);
            el.style.display = 'none';
        });

        // Utw√≥rz nowy canvas do renderowania SVG
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Ustaw rozmiar canvas na rozmiar obszaru roboczego
        const workspace = document.getElementById('workspace');
        canvas.width = workspace.offsetWidth;
        canvas.height = workspace.offsetHeight;

        // Wype≈Çnij t≈Ço bia≈Çym kolorem
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Konwertuj SVG na obraz i rysuj na canvas
        const svgData = new XMLSerializer().serializeToString(svgCanvas);
        const img = new Image();

        img.onload = function() {
            // Narysuj obraz na canvas
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Konwertuj canvas na obraz PNG i pobierz
            const dataURL = canvas.toDataURL('image/png');
            const downloadLink = document.createElement('a');
            downloadLink.download = 'digital-twin-export.png';
            downloadLink.href = dataURL;
            downloadLink.click();

            // Przywr√≥ƒá elementy interfejsu
            uiElements.forEach((el, index) => {
                el.style.display = originalDisplays[index];
            });
        };

        // Ustaw ≈∫r√≥d≈Ço obrazu jako zakodowane w base64 dane SVG
        img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
    }

    window.exportAsSVG = () => {
        // Pobierz zawarto≈õƒá SVG
        const svgData = new XMLSerializer().serializeToString(svgCanvas);

        // Utw√≥rz link do pobrania
        const blob = new Blob([svgData], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);

        // Utw√≥rz i kliknij link do pobrania
        const a = document.createElement('a');
        a.href = url;
        a.download = 'digital-twin-export.svg';
        document.body.appendChild(a);
        a.click();

        // PosprzƒÖtaj
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    // --- SYMULACJA DANYCH ---
    window.startSimulation = () => {
        if (simulationInterval) return;

        simulationInterval = setInterval(() => {
            svgCanvas.querySelectorAll("svg[data-id]").forEach(comp => {
                const metadataNode = comp.querySelector("metadata");
                if (!metadataNode) return;

                let metadata;
                try {
                    metadata = JSON.parse(metadataNode.textContent);
                } catch (e) {
                    return;
                }

                const params = metadata.parameters;
                if (!params.isActive) return;

                // Symuluj wszystkie liczbowe parametry
                Object.keys(params).forEach(key => {
                    if (typeof params[key] === "number" && !key.includes("Min") && !key.includes("Max") && key !== "size") {
                        const min = params[`${key}Min`] ?? 0;
                        const max = params[`${key}Max`] ?? 100;
                        const newVal = min + Math.random() * (max - min);
                        params[key] = parseFloat(newVal.toFixed(2));

                        metadataNode.textContent = JSON.stringify(metadata, null, 2);
                        applyParameterToSVG(comp, key, params[key]);

                        const displayEl = document.getElementById(`sim-value-${metadata.id}`);
                        if (displayEl) displayEl.textContent = params[key];
                    }
                });
            });
        }, 1000);
    };

    window.stopSimulation = () => {
        if (simulationInterval) clearInterval(simulationInterval);
        simulationInterval = null;
    };

    function refreshSimulationList() {
        const list = document.getElementById("simulation-list");
        list.innerHTML = "";

        svgCanvas.querySelectorAll("svg[data-id]").forEach(comp => {
            const metadataNode = comp.querySelector("metadata");
            if (!metadataNode) return;

            let metadata;
            try {
                metadata = JSON.parse(metadataNode.textContent);
            } catch (e) {
                return;
            }

            if (metadata.parameters.value !== undefined) {
                const el = document.createElement("p");
                el.innerHTML = `<strong>${metadata.name}</strong>: <span id="sim-value-${metadata.id}">${metadata.parameters.value}</span>`;
                list.appendChild(el);
            }
        });

        if (list.children.length === 0) {
            list.innerHTML = "<p><i>Brak komponent√≥w z parametrem 'value'</i></p>";
        }
    }

    // --- DODAJ PARAMETR ---
    window.addParameter = (id) => {
        const name = prompt("Nazwa parametru (np. pressure):");
        if (!name) return;

        const type = prompt("Typ (string, number, boolean)", "number");
        let value;
        switch (type) {
            case "number":
                value = 0;
                break;
            case "boolean":
                value = false;
                break;
            default:
                value = "nowy";
        }

        const comp = svgCanvas.querySelector(`[data-id="${id}"]`);
        const metadataNode = comp.querySelector("metadata");
        let metadata;

        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            metadata = {id, parameters: {}};
        }

        metadata.parameters[name] = value;
        metadataNode.textContent = JSON.stringify(metadata, null, 2);
        selectComponent(comp);
    };

    // --- PWA ---
    if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("sw.js").then(() => {
            console.log("SW zarejestrowany");
        });
    }

    function updateMetadataInSVG(svgElement, path, value) {
        // Pobierz metadane
        let metadata = {};
        let metadataNode = svgElement.querySelector('metadata');

        if (metadataNode && metadataNode.textContent.trim()) {
            try {
                metadata = JSON.parse(metadataNode.textContent);
            } catch (e) {
                console.warn('B≈ÇƒÖd parsowania metadanych:', e);
            }
        } else if (!metadataNode) {
            // Je≈õli nie ma wƒôz≈Ça metadanych, utw√≥rz nowy
            metadataNode = document.createElement('metadata');
            svgElement.appendChild(metadataNode);
        }

        // Zaktualizuj warto≈õƒá w ≈õcie≈ºce (np. 'parameters.speed')
        const keys = path.split('.');
        let current = metadata;

        for (let i = 0; i < keys.length - 1; i++) {
            if (current[keys[i]] === undefined) {
                current[keys[i]] = {};
            }
            current = current[keys[i]];
        }

        current[keys[keys.length - 1]] = value;

        // Zapisz zaktualizowane metadane
        metadataNode.textContent = JSON.stringify(metadata, null, 2);

        // Zastosuj zmiany do wizualizacji
        applyParameterToSVG(svgElement, path, value);
    }

    function applyParameterToSVG(svgElement, paramKey, value) {
        if (!svgElement) return;

        // Pobierz metadane
        const metadataNode = svgElement.querySelector('metadata');
        if (!metadataNode) return;

        let metadata;
        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            console.warn('B≈ÇƒÖd parsowania metadanych:', e);
            return;
        }

        const componentType = metadata.type || 'default';
        const instanceId = svgElement.getAttribute('data-id');

        // Obs≈Çu≈º r√≥≈ºne typy komponent√≥w
        switch (componentType) {
            case 'led':
                // Dla LED-√≥w, zaktualizuj odpowiednie elementy
                const ledCore = svgElement.querySelector('#led-core');
                const labelEl = svgElement.querySelector('#label');
                const params = metadata.parameters || {};

                if (paramKey === 'parameters.label' && labelEl) {
                    labelEl.textContent = value;
                }

                if (ledCore) {
                    if (paramKey === 'parameters.color' || paramKey === 'parameters.isOn' || paramKey === 'parameters.isBlinking') {
                        // Zatrzymaj istniejƒÖce miganie
                        if (svgElement.blinkInterval) {
                            clearInterval(svgElement.blinkInterval);
                            svgElement.blinkInterval = null;
                        }

                        // Ustaw nowy kolor lub stan
                        if (params.isBlinking && params.isOn) {
                            let on = true;
                            svgElement.blinkInterval = setInterval(() => {
                                ledCore.setAttribute('fill', on ? (params.color || '#e74c3c') : '#333');
                                on = !on;
                            }, params.blinkRate || 500);
                        } else {
                            ledCore.setAttribute('fill', params.isOn ? (params.color || '#e74c3c') : '#333');
                        }
                    }
                }
                break;

            case 'knob':
                // Obs≈Çuga pokrƒôt≈Ça
                const knobBody = svgElement.querySelector('.knob-body');
                const knobIndicator = svgElement.querySelector('.knob-indicator');
                const knobLabel = svgElement.querySelector('.knob-label');
                const knobValue = svgElement.querySelector('.knob-value');
                const knobParams = metadata.parameters || {};
                
                if (paramKey === 'parameters.label' && knobLabel) {
                    knobLabel.textContent = value;
                }
                
                if (paramKey === 'parameters.color' && knobBody) {
                    knobBody.setAttribute('fill', value);
                }
                
                if ((paramKey === 'parameters.value' || 
                     paramKey === 'parameters.min' || 
                     paramKey === 'parameters.max') && knobIndicator) {
                    // Oblicz kƒÖt obrotu na podstawie warto≈õci
                    const min = knobParams.min || 0;
                    const max = knobParams.max || 100;
                    const val = Math.min(Math.max(knobParams.value, min), max);
                    const percentage = (val - min) / (max - min);
                    const angle = percentage * 270 - 135; // -135¬∞ do +135¬∞

                    // Zastosuj obr√≥t do wska≈∫nika
                    knobIndicator.setAttribute('transform', `rotate(${angle} 20 20)`);

                    // Aktualizuj tekst warto≈õci
                    if (knobValue) {
                        knobValue.textContent = val;
                    }
                }
                break;

            case 'slider':
                // Obs≈Çuga suwaka
                const sliderTrack = svgElement.querySelector('.slider-track');
                const sliderProgress = svgElement.querySelector('.slider-progress');
                const sliderHandle = svgElement.querySelector('.slider-handle');
                const sliderLabel = svgElement.querySelector('.slider-label');
                const sliderValue = svgElement.querySelector('.slider-value');
                const sliderParams = metadata.parameters || {};
                
                if (paramKey === 'parameters.label' && sliderLabel) {
                    sliderLabel.textContent = value;
                }
                
                if (paramKey === 'parameters.color' && sliderProgress) {
                    sliderProgress.setAttribute('fill', value);
                }
                
                if ((paramKey === 'parameters.value' || 
                     paramKey === 'parameters.min' || 
                     paramKey === 'parameters.max') && sliderHandle) {
                    // Oblicz pozycjƒô na podstawie warto≈õci
                    const min = sliderParams.min || 0;
                    const max = sliderParams.max || 100;
                    const val = Math.min(Math.max(sliderParams.value, min), max);
                    const percentage = (val - min) / (max - min);
                    
                    // Szeroko≈õƒá toru
                    const trackWidth = 40;
                    const startX = 10;
                    const handleX = startX + percentage * trackWidth;
                    
                    // Aktualizuj pozycjƒô uchwytu
                    sliderHandle.setAttribute('cx', handleX);
                    
                    // Aktualizuj szeroko≈õƒá paska postƒôpu
                    if (sliderProgress) {
                        const progressWidth = percentage * trackWidth;
                        sliderProgress.setAttribute('width', progressWidth);
                    }
                    
                    // Aktualizuj tekst warto≈õci
                    if (sliderValue) {
                        sliderValue.textContent = val;
                    }
                }
                break;

            // Dodaj inne typy komponent√≥w tutaj

            default:
                // Domy≈õlna obs≈Çuga dla nieznanych typ√≥w
                const element = svgElement.querySelector(`#${paramKey}`);
                if (element) {
                    if (typeof value === 'object') {
                        Object.entries(value).forEach(([attr, val]) => {
                            element.setAttribute(attr, val);
                        });
                    } else {
                        element.textContent = value;
                    }
                }
        }
    }

    function updateParam(id, paramKey, value, type) {
        if (type === 'number') value = parseFloat(value);
        if (type === 'boolean') value = value === true || value === 'true';

        const svgElement = document.querySelector(`[data-id="${id}"]`);
        if (!svgElement) return;

        // Aktualizuj metadane
        updateMetadataInSVG(svgElement, `parameters.${paramKey}`, value);

        // Zastosuj zmiany do wizualizacji
        applyParameterToSVG(svgElement, paramKey, value);
    }

    function removeComponent(id) {
        const component = components.get(id);
        if (!component) return;

        // Zatrzymaj wszystkie interwa≈Çy zwiƒÖzane z tym komponentem
        if (component.element.blinkInterval) {
            clearInterval(component.element.blinkInterval);
        }
        if (component.element.pollingInterval) {
            clearInterval(component.element.pollingInterval);
        }

        // Usu≈Ñ element z DOM
        if (component.element && component.element.parentNode) {
            component.element.parentNode.removeChild(component.element);
        }

        // Usu≈Ñ z mapy komponent√≥w
        components.delete(id);

        // Usu≈Ñ po≈ÇƒÖczenia zwiƒÖzane z tym komponentem
        updateConnections(id, true);

        // Wyczy≈õƒá panel w≈Ça≈õciwo≈õci
        const propertiesPanel = document.getElementById('properties-panel');
        if (propertiesPanel) {
            propertiesPanel.style.display = 'none';
        }

        if (selectedComponent && selectedComponent.getAttribute('data-id') === id) {
            selectedComponent = null;
        }
    }

    function editMetadataRaw(id) {
        const el = document.querySelector(`[data-id="${id}"]`);
        const metadataNode = el.querySelector("metadata");
        let metadata;

        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            alert("B≈ÇƒÖd: niepoprawny JSON w metadanych");
            return;
        }

        const jsonStr = JSON.stringify(metadata, null, 2);
        const newJson = prompt("Edytuj metadane (JSON):", jsonStr);

        if (newJson) {
            try {
                JSON.parse(newJson); // walidacja
                metadataNode.textContent = newJson;
                selectComponent(el); // od≈õwie≈º panel
                alert("Metadane zaktualizowane!");
            } catch (e) {
                alert("B≈ÇƒÖd sk≈Çadni JSON: " + e.message);
            }
        }
    }

    function updatePosition(id, coord, value) {
        const el = document.querySelector(`[data-id="${id}"]`);
        if (!el) return;

        const numValue = parseFloat(value);
        if (isNaN(numValue)) return;

        const currentX = parseFloat(el.getAttribute("x"));
        const currentY = parseFloat(el.getAttribute("y"));
        const size = el.querySelector("metadata") ?
            JSON.parse(el.querySelector("metadata").textContent).parameters?.size || 50 : 50;

        // Oblicz nowƒÖ pozycjƒô kontenera
        if (coord === "x") {
            el.setAttribute("x", numValue - size / 2);
        } else {
            el.setAttribute("y", numValue - size / 2);
        }

        // Aktualizuj metadane
        const metadataNode = el.querySelector("metadata");
        if (metadataNode) {
            let metadata;
            try {
                metadata = JSON.parse(metadataNode.textContent);
            } catch (e) {
                return;
            }
            metadata.position[coord] = Math.round(numValue);
            metadataNode.textContent = JSON.stringify(metadata, null, 2);
        }

        // Od≈õwie≈º panel (≈ºeby zobaczyƒá zmianƒô)
        showProperties(el);
    };

    // Za≈Çaduj komponenty do biblioteki z ikonami
    async function loadComponentLibrary() {
        const container = document.getElementById("component-library");
        if (!container) {
            console.error("Nie znaleziono kontenera biblioteki komponent√≥w (component-library)");
            return;
        }

        container.innerHTML = ""; // wyczy≈õƒá

        for (const comp of COMPONENTS) {
            try {
                const response = await fetch(comp.svg);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const svgText = await response.text();
                if (!svgText || !svgText.trim().startsWith('<svg') && !svgText.trim().startsWith('<?xml')) {
                    throw new Error("Nieprawid≈Çowy format SVG");
                }

                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, "image/svg+xml");

                // Sprawd≈∫ b≈Çƒôdy parsowania
                const parserError = svgDoc.querySelector("parsererror");
                if (parserError) {
                    throw new Error("B≈ÇƒÖd parsowania SVG");
                }

                const svgElement = svgDoc.documentElement;
                if (!svgElement || svgElement.nodeName !== 'svg') {
                    throw new Error("Nie znaleziono elementu SVG");
                }

                // Przygotuj SVG jako ikona - u≈ºywamy setAttribute zamiast style
                svgElement.setAttribute("width", "32");
                svgElement.setAttribute("height", "32");
                svgElement.removeAttribute("id");

                // U≈ºywamy setAttribute zamiast style.display
                svgElement.setAttribute("style", "display: block;");

                // Tworzymy przycisk
                const button = document.createElement("button");
                button.className = "component-button";
                button.draggable = true;
                button.dataset.svg = comp.svg;
                button.title = comp.name;

                // Ikona po lewej
                const iconWrapper = document.createElement("div");
                iconWrapper.setAttribute("style", "width: 36px; height: 36px; flex-shrink: 0;");
                iconWrapper.appendChild(svgElement);

                // Tekst
                const label = document.createElement("span");
                label.textContent = comp.name;

                // Dodaj do przycisku
                button.appendChild(iconWrapper);
                button.appendChild(label);

                // Obs≈Çuga przeciƒÖgania
                button.addEventListener("dragstart", (e) => {
                    e.dataTransfer.setData("text/plain", comp.svg);
                });

                container.appendChild(button);
            } catch (err) {
                console.error(`B≈ÇƒÖd ≈Çadowania ikony ${comp.svg}:`, err);
                const fallbackButton = document.createElement("button");
                fallbackButton.className = "component-button";
                fallbackButton.draggable = true;
                fallbackButton.dataset.svg = comp.svg;
                fallbackButton.innerHTML = `<span>‚ö†Ô∏è ${comp.name}</span>`;
                fallbackButton.title = "B≈ÇƒÖd ≈Çadowania ikony";

                // Sprawd≈∫ czy kontener istnieje przed dodaniem przycisku awaryjnego
                const componentLibrary = document.getElementById("component-library");
                if (componentLibrary) {
                    componentLibrary.appendChild(fallbackButton);
                }
            }
        }
    }

    // Uruchom po za≈Çadowaniu DOM
    document.addEventListener("DOMContentLoaded", loadComponentLibrary);
</script>
</body>
</html>
