<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Digital Twin IDE</title>
    
    <!-- External Stylesheets -->
    <link rel="stylesheet" href="css/styles.css"/>
    <link rel="stylesheet" href="css/app.css"/>
    
    <!-- PWA Manifest and Icons -->
    <link rel="manifest" href="manifest.json"/>
    <link rel="icon" href="assets/icons/icon-192.png"/>
    
    <!-- Meta tags for better SEO and PWA -->
    <meta name="description" content="Digital Twin IDE - Interactive component design and simulation tool"/>
    <meta name="theme-color" content="#2c3e50"/>
    <meta name="apple-mobile-web-app-capable" content="yes"/>
    <meta name="apple-mobile-web-app-status-bar-style" content="default"/>
</head>
<body>
    <!-- Toolbar -->
    <div class="toolbar">
        <button onclick="exportProject()" style="background: #27ae60; color: white;">üì§ Eksportuj (.dtwin)</button>
        <button onclick="importProject()" style="background: #3498db; color: white;">üì• Importuj (.dtwin)</button>
        <button onclick="exportAsPNG()" style="background: #e67e22; color: white;">üñºÔ∏è PNG</button>
        <button onclick="exportAsSVG()" style="background: #3498db; color: white;">üü© SVG</button>
        <button onclick="toggleConnectionMode()" style="background: #8e44ad; color: white;">üîó ≈ÅƒÖcz komponenty</button>
    </div>

    <!-- Simulation Panel -->
    <div class="simulation-panel">
        <h3>üìä Symulacja Danych</h3>
        <button onclick="startSimulation()" style="background: #27ae60; color: white;">‚ñ∂Ô∏è Start</button>
        <button onclick="stopSimulation()" style="background: #e74c3c; color: white;">‚è∏Ô∏è Stop</button>
        <div id="simulation-list" style="margin-top: 10px; max-height: 150px; overflow-y: auto;">
            <p><i>Brak komponent√≥w do symulacji</i></p>
        </div>
    </div>

    <!-- Main Layout -->
    <div class="container">
        <!-- Left Sidebar: Components Library -->
        <aside class="sidebar left">
            <h3>üîß Komponenty</h3>
            <div class="component-list" id="component-library">
                <!-- Components will be loaded dynamically -->
                <div class="loading">≈Åadowanie komponent√≥w...</div>
            </div>
        </aside>

        <!-- Center: Workspace Canvas -->
        <div class="workspace" id="workspace">
            <svg id="svg-canvas" xmlns="http://www.w3.org/2000/svg">
                <!-- SVG Definitions -->
                <defs>
                    <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" 
                            markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                        <path d="M 0 0 L 10 5 L 0 10 z" fill="#2c3e50"/>
                    </marker>
                    <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                        <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#ddd" stroke-width="0.5"/>
                    </pattern>
                </defs>
                
                <!-- Grid Background -->
                <rect width="100%" height="100%" fill="url(#grid)"/>
                
                <!-- Components and connections will be added dynamically here -->
            </svg>
        </div>

        <!-- Right Sidebar: Properties Panel -->
        <aside class="sidebar right">
            <h3>‚öôÔ∏è W≈Ça≈õciwo≈õci</h3>
            <div id="properties-panel">
                <p>Wybierz komponent, aby edytowaƒá w≈Ça≈õciwo≈õci.</p>
            </div>
        </aside>
    </div>

    <!-- JavaScript Modules -->
    <script type="module" src="js/app.js"></script>
    
    <!-- Noscript fallback -->
    <noscript>
        <div style="text-align: center; padding: 50px; font-family: Arial, sans-serif;">
            <h2>JavaScript Required</h2>
            <p>Aplikacja Digital Twin IDE wymaga w≈ÇƒÖczonej obs≈Çugi JavaScript w przeglƒÖdarce.</p>
            <p>Proszƒô w≈ÇƒÖczyƒá JavaScript i od≈õwie≈ºyƒá stronƒô.</p>
        </div>
    </noscript>
                    }
                } catch (e) {
                    console.warn("Niepoprawne metadane w oryginalnym SVG:", e);
                }
            } else {
                // Utw√≥rz nowe <metadata>, je≈õli nie istnieje
                metadataNode = document.createElementNS("http://www.w3.org/2000/svg", "metadata");
                svgElement.prepend(metadataNode);
            }

            // Dodaj lub zaktualizuj pozycjƒô w metadanych
            metadata.position = {x: canvasX, y: canvasY};
            metadata.id = metadata.id || componentId; // Zachowaj ID z pliku lub nadaj nowe
            metadata.instanceId = componentId; // Unikalne ID instancji
            metadata.parameters = metadata.parameters || {}; // Upewnij siƒô, ≈ºe parameters istnieje

            // Zapisz zaktualizowane metadane
            metadataNode.textContent = JSON.stringify(metadata, null, 2);

            // Ustaw pozycjƒô kontenera SVG
            const defaultSize = 50;
            const size = metadata.parameters.size || defaultSize;
            svgElement.setAttribute("x", canvasX - size / 2);
            svgElement.setAttribute("y", canvasY - size / 2);

            // Zdarzenia
            svgElement.addEventListener("click", (ev) => {
                ev.stopPropagation();
                if (isConnectionMode) {
                    startConnection(svgElement);
                } else {
                    selectComponent(svgElement);
                }
            });

            makeDraggable(svgElement);

            if (svgCanvas) {
                svgCanvas.appendChild(svgElement);
                // Od≈õwie≈º panel symulacji
                setTimeout(refreshSimulationList, 100);
            } else {
                console.error("Nie znaleziono kontenera SVG canvas");
            }
        } catch (err) {
            console.error("B≈ÇƒÖd ≈Çadowania SVG:", err);
            alert(`Nie uda≈Ço siƒô za≈Çadowaƒá komponentu: ${err.message}`);
        }
    });

    // --- WYB√ìR KOMPONENTU ---
    function selectComponent(el) {
        // Sprawd≈∫, czy element istnieje
        if (!el) return;

        const propertiesPanel = document.getElementById('properties-panel');
        if (!propertiesPanel) {
            console.error("Nie znaleziono panelu w≈Ça≈õciwo≈õci (properties-panel)");
            return;
        }

        // Je≈õli klikniƒôto w to samo, odznacz
        if (selectedComponent === el) {
            el.style.outline = '';
            selectedComponent = null;
            propertiesPanel.style.display = 'none';
            return;
        }

        // Usu≈Ñ zaznaczenie z poprzedniego komponentu
        if (selectedComponent) {
            selectedComponent.style.outline = '';
        }

        // Zaznacz nowy komponent
        selectedComponent = el;
        el.style.outline = '2px solid #3498db';

        // Poka≈º w≈Ça≈õciwo≈õci
        showProperties(el);
    }

    // --- EDYCJA W≈ÅA≈öCIWO≈öCI ---
    function showProperties(svgElement) {
        // Sprawd≈∫, czy element istnieje
        if (!svgElement) return;

        const propertiesPanel = document.getElementById("properties-panel");
        if (!propertiesPanel) {
            console.error("Nie znaleziono panelu w≈Ça≈õciwo≈õci (properties-panel)");
            return;
        }

        propertiesPanel.style.display = "block";
        propertiesPanel.innerHTML = "<h3>W≈Ça≈õciwo≈õci</h3>";

        // Pobierz ID komponentu
        const id = svgElement.getAttribute('data-id');
        if (!id) return;

        // Pobierz metadane
        const metadataNode = svgElement.querySelector("metadata");
        if (!metadataNode) return;

        let metadata;
        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            console.error("B≈ÇƒÖd parsowania metadanych:", e);
            return;
        }

        // Dodaj przycisk usuwania
        const deleteBtn = document.createElement("button");
        deleteBtn.textContent = "Usu≈Ñ komponent";
        deleteBtn.onclick = () => removeComponent(id);
        propertiesPanel.appendChild(deleteBtn);

        // Dodaj przycisk edycji surowych metadanych
        const editBtn = document.createElement("button");
        editBtn.textContent = "Edytuj metadane";
        editBtn.onclick = () => editMetadataRaw(id);
        propertiesPanel.appendChild(editBtn);

        // Dodaj w≈Ça≈õciwo≈õci
        if (metadata.parameters) {
            const params = metadata.parameters;
            Object.entries(params).forEach(([key, value]) => {
                const paramDiv = document.createElement("div");
                paramDiv.className = "property";

                const label = document.createElement("label");
                label.textContent = formatLabel(key) + ": ";

                let input;

                if (typeof value === 'boolean') {
                    input = document.createElement("input");
                    input.type = "checkbox";
                    input.checked = value;
                    input.onchange = (e) => updateParam(id, key, e.target.checked, 'boolean');
                } else if (typeof value === 'number') {
                    input = document.createElement("input");
                    input.type = "number";
                    input.value = value;
                    input.onchange = (e) => updateParam(id, key, parseFloat(e.target.value), 'number');
                } else if (typeof value === 'string' && key === 'color') {
                    input = document.createElement("input");
                    input.type = "color";
                    input.value = value || '#3498db';
                    input.onchange = (e) => updateParam(id, key, e.target.value, 'color');
                } else {
                    input = document.createElement("input");
                    input.type = "text";
                    input.value = value;
                    input.onchange = (e) => updateParam(id, key, e.target.value, 'string');
                }

                paramDiv.appendChild(label);
                paramDiv.appendChild(input);
                propertiesPanel.appendChild(paramDiv);
            });

            // Dodaj przycisk dodawania nowego parametru
            const addParamBtn = document.createElement("button");
            addParamBtn.textContent = "Dodaj parametr";
            addParamBtn.onclick = () => addParameter(id);
            propertiesPanel.appendChild(addParamBtn);
        }
    }

    // --- PRZECIƒÑGANIE KOMPONENT√ìW PO PLANSZY ---
    function makeDraggable(svgElement) {
        let isDragging = false;
        let offsetX, offsetY;

        svgElement.setAttribute('draggable', 'false'); // Zapobiegaj domy≈õlnemu zachowaniu przeglƒÖdarki

        svgElement.addEventListener('mousedown', startDrag);

        function startDrag(e) {
            if (e.button !== 0) return;

            const rect = svgElement.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;

            selectComponent(svgElement);

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', stopDrag);

            e.preventDefault();
            isDragging = true;
        }

        function onDrag(e) {
            if (!isDragging) return;

            const x = e.clientX - offsetX - workspace.getBoundingClientRect().left;
            const y = e.clientY - offsetY - workspace.getBoundingClientRect().top;

            const maxX = workspace.offsetWidth - svgElement.width.baseVal.value;
            const maxY = workspace.offsetHeight - svgElement.height.baseVal.value;

            const newX = Math.max(0, Math.min(x, maxX));
            const newY = Math.max(0, Math.min(y, maxY));

            svgElement.setAttribute('x', newX);
            svgElement.setAttribute('y', newY);

            const id = svgElement.getAttribute('data-id');
            if (id) {
                updatePosition(id, 'x', newX);
                updatePosition(id, 'y', newY);
            }

            updateConnections(id);
        }

        function stopDrag() {
            if (!isDragging) return;

            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', stopDrag);

            isDragging = false;
        }
    }

    // --- ≈ÅƒÑCZENIE KOMPONENT√ìW ---
    window.toggleConnectionMode = () => {
        isConnectionMode = !isConnectionMode;
        svgCanvas.style.cursor = isConnectionMode ? "crosshair" : "default";
        alert(isConnectionMode ? "üîÅ Tryb ≈ÇƒÖczenia: kliknij dwa komponenty." : "üéØ Tryb edycji.");
        if (!isConnectionMode && connectionStart) {
            connectionStart.style.outline = "";
            connectionStart = null;
        }
    };

    function startConnection(svgElement) {
        const metadataNode = svgElement.querySelector("metadata");
        if (!metadataNode) return;

        let metadata;
        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            return;
        }

        if (!metadata.position) {
            alert("Ten komponent nie jest jeszcze umieszczony na planszy.");
            return;
        }

        if (!isConnectionMode) return;

        if (!connectionStart) {
            connectionStart = svgElement;
            svgElement.style.outline = "3px dashed yellow";
        } else {
            if (connectionStart !== svgElement) {
                createConnection(connectionStart, svgElement);
            }
            connectionStart.style.outline = "";
            connectionStart = null;
        }
    }

    function createConnection(comp1, comp2) {
        const x1 = parseFloat(comp1.getAttribute("x")) + 30;
        const y1 = parseFloat(comp1.getAttribute("y")) + 30;
        const x2 = parseFloat(comp2.getAttribute("x")) + 30;
        const y2 = parseFloat(comp2.getAttribute("y")) + 30;

        const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
        line.setAttribute("x1", x1);
        line.setAttribute("y1", y1);
        line.setAttribute("x2", x2);
        line.setAttribute("y2", y2);
        line.setAttribute("stroke", "#2c3e50");
        line.setAttribute("stroke-width", "2");
        line.setAttribute("marker-end", "url(#arrow)");
        line.dataset.connection = "true";

        svgCanvas.appendChild(line);
    }

    // --- EKSPORT / IMPORT ---
    window.exportProject = () => {
        const components = [];
        const lines = [];

        svgCanvas.querySelectorAll("svg[data-id]").forEach(instance => {
            const metadataNode = instance.querySelector("metadata");
            if (!metadataNode) return;

            let metadata;
            try {
                metadata = JSON.parse(metadataNode.textContent);
            } catch (e) {
                return;
            }

            components.push({
                id: metadata.id,
                svgUrl: instance.dataset.svgUrl,
                x: parseFloat(instance.getAttribute("x")),
                y: parseFloat(instance.getAttribute("y")),
                metadata: metadata
            });
        });

        svgCanvas.querySelectorAll("line[data-connection]").forEach(line => {
            lines.push({
                x1: line.getAttribute("x1"),
                y1: line.getAttribute("y1"),
                x2: line.getAttribute("x2"),
                y2: line.getAttribute("y2")
            });
        });

        const project = {
            version: "1.1",
            createdAt: new Date().toISOString(),
            components,
            connections: lines
        };

        const blob = new Blob([JSON.stringify(project, null, 2)], {type: "application/json"});
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `digital-twin-${new Date().toISOString().split("T")[0]}.dtwin.json`;
        a.click();
        URL.revokeObjectURL(url);
    };

    window.importProject = () => {
        const input = document.createElement("input");
        input.type = "file";
        input.accept = ".dtwin.json";

        input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;

            try {
                const content = await file.text();
                const project = JSON.parse(content);

                // Wyczy≈õƒá
                svgCanvas.innerHTML = `
            <defs>
              <marker id="arrow" viewBox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse">
                <path d="M 0 0 L 10 5 L 0 10 z" fill="#2c3e50" />
              </marker>
              <pattern id="grid" width="20" height="20" patternUnits="userSpaceOnUse">
                <path d="M 20 0 L 0 0 0 20" fill="none" stroke="#ddd" stroke-width="0.5"/>
              </pattern>
            </defs>
            <rect width="100%" height="100%" fill="url(#grid)" />
          `;

                // Wczytaj komponenty
                for (const comp of project.components) {
                    try {
                        const response = await fetch(comp.svgUrl);
                        if (!response.ok) {
                            throw new Error(`HTTP error! status: ${response.status}`);
                        }

                        const svgText = await response.text();
                        if (!svgText || !svgText.trim().startsWith('<svg') && !svgText.trim().startsWith('<?xml')) {
                            throw new Error("Nieprawid≈Çowy format SVG");
                        }

                        const parser = new DOMParser();
                        const svgDoc = parser.parseFromString(svgText, "image/svg+xml");

                        // Sprawd≈∫ b≈Çƒôdy parsowania
                        const parserError = svgDoc.querySelector("parsererror");
                        if (parserError) {
                            throw new Error("B≈ÇƒÖd parsowania SVG");
                        }

                        const svgElement = svgDoc.documentElement;
                        if (!svgElement || svgElement.nodeName !== 'svg') {
                            throw new Error("Nie znaleziono elementu SVG");
                        }

                        // Generuj nowe ID
                        const componentId = `comp-${componentCounter++}`;
                        svgElement.setAttribute("data-id", componentId);
                        svgElement.setAttribute("data-svgUrl", comp.svgUrl);
                        svgElement.setAttribute("class", "draggable-component");
                        svgElement.setAttribute("style", "cursor: move;");

                        // Pobierz lub utw√≥rz metadane
                        let metadataNode = svgElement.querySelector("metadata");
                        let metadata = {parameters: {}};

                        if (metadataNode) {
                            try {
                                const metadataContent = metadataNode.textContent.trim();
                                if (metadataContent) {
                                    metadata = JSON.parse(metadataContent);
                                }
                            } catch (e) {
                                console.warn("Niepoprawne metadane w oryginalnym SVG:", e);
                            }
                        } else {
                            // Utw√≥rz nowe <metadata>, je≈õli nie istnieje
                            metadataNode = document.createElementNS("http://www.w3.org/2000/svg", "metadata");
                            svgElement.prepend(metadataNode);
                        }

                        // Dodaj lub zaktualizuj pozycjƒô w metadanych
                        metadata.position = {x: comp.x, y: comp.y};
                        metadata.id = metadata.id || componentId; // Zachowaj ID z pliku lub nadaj nowe
                        metadata.instanceId = componentId; // Unikalne ID instancji
                        metadata.parameters = metadata.parameters || {}; // Upewnij siƒô, ≈ºe parameters istnieje

                        // Zapisz zaktualizowane metadane
                        metadataNode.textContent = JSON.stringify(metadata, null, 2);

                        // Ustaw pozycjƒô kontenera SVG
                        const defaultSize = 50;
                        const size = metadata.parameters.size || defaultSize;
                        svgElement.setAttribute("x", comp.x - size / 2);
                        svgElement.setAttribute("y", comp.y - size / 2);

                        // Zdarzenia
                        svgElement.addEventListener("click", (ev) => {
                            ev.stopPropagation();
                            if (isConnectionMode) {
                                startConnection(svgElement);
                            } else {
                                selectComponent(svgElement);
                            }
                        });

                        makeDraggable(svgElement);
                        svgCanvas.appendChild(svgElement);
                    } catch (err) {
                        console.error("B≈ÇƒÖd komponentu:", err);
                    }
                }

                // Wczytaj linie
                project.connections.forEach(conn => {
                    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                    line.setAttribute("x1", conn.x1);
                    line.setAttribute("y1", conn.y1);
                    line.setAttribute("x2", conn.x2);
                    line.setAttribute("y2", conn.y2);
                    line.setAttribute("stroke", "#2c3e50");
                    line.setAttribute("stroke-width", "2");
                    line.setAttribute("marker-end", "url(#arrow)");
                    line.dataset.connection = "true";
                    svgCanvas.appendChild(line);
                });

                setTimeout(refreshSimulationList, 500);
                alert(`Import: ${project.components.length} komponent√≥w, ${project.connections.length} po≈ÇƒÖcze≈Ñ.`);
            } catch (err) {
                alert("B≈ÇƒÖd importu!");
                console.error(err);
            }
        };

        input.click();
    };

    // --- EKSPORT JAKO OBRAZ ---
    window.exportAsPNG = () => {
        // Tymczasowo ukryj elementy interfejsu, kt√≥rych nie chcemy na zrzucie
        const uiElements = document.querySelectorAll('.toolbar, .sidebar, #properties-panel');
        const originalDisplays = [];

        // Zapisz oryginalne style i ukryj elementy interfejsu
        uiElements.forEach(el => {
            originalDisplays.push(el.style.display);
            el.style.display = 'none';
        });

        // Utw√≥rz nowy canvas do renderowania SVG
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        // Ustaw rozmiar canvas na rozmiar obszaru roboczego
        const workspace = document.getElementById('workspace');
        canvas.width = workspace.offsetWidth;
        canvas.height = workspace.offsetHeight;

        // Wype≈Çnij t≈Ço bia≈Çym kolorem
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Konwertuj SVG na obraz i rysuj na canvas
        const svgData = new XMLSerializer().serializeToString(svgCanvas);
        const img = new Image();

        img.onload = function() {
            // Narysuj obraz na canvas
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

            // Konwertuj canvas na obraz PNG i pobierz
            const dataURL = canvas.toDataURL('image/png');
            const downloadLink = document.createElement('a');
            downloadLink.download = 'digital-twin-export.png';
            downloadLink.href = dataURL;
            downloadLink.click();

            // Przywr√≥ƒá elementy interfejsu
            uiElements.forEach((el, index) => {
                el.style.display = originalDisplays[index];
            });
        };

        // Ustaw ≈∫r√≥d≈Ço obrazu jako zakodowane w base64 dane SVG
        img.src = 'data:image/svg+xml;base64,' + btoa(unescape(encodeURIComponent(svgData)));
    }

    window.exportAsSVG = () => {
        // Stw√≥rz tymczasowƒÖ kopiƒô SVG canvas
        const tempSvgCanvas = svgCanvas.cloneNode(true);

        // Znajd≈∫ wszystkie komponenty i dodaj im unikalne identyfikatory
        const nestedSvgs = tempSvgCanvas.querySelectorAll('svg[data-id]');
        nestedSvgs.forEach((svg, index) => {
            svg.setAttribute('data-export-id', `component-${index}`);
        });

        // Dodaj skrypt inicjalizacyjny dla obs≈Çugi zdarze≈Ñ myszy
        const scriptNode = document.createElementNS('http://www.w3.org/2000/svg', 'script');
        scriptNode.textContent = `
            // Funkcja inicjalizujƒÖca zdarzenia myszy dla wszystkich komponent√≥w
            (function() {
                // Funkcja pomocnicza - sprawdza czy punkt jest wewnƒÖtrz elementu
                function isPointInElement(point, element) {
                    const rect = element.getBoundingClientRect();
                    return (
                        point.x >= rect.left &&
                        point.x <= rect.right &&
                        point.y >= rect.top &&
                        point.y <= rect.bottom
                    );
                }

                // Zmienne globalne do ≈õledzenia aktywnego komponentu
                let activeComponentId = null;
                let hoveredComponentId = null;

                // Funkcja do blokowania interakcji dla wszystkich komponent√≥w poza aktywnym
                function updateComponentsInteractivity(e) {
                    const mousePoint = { x: e.clientX, y: e.clientY };
                    let foundHovered = false;

                    // Przeszukaj wszystkie komponenty od g√≥ry (z-index) do do≈Çu
                    const allComponents = Array.from(document.querySelectorAll('svg[data-export-id]'));

                    // Znajd≈∫ komponent, nad kt√≥rym jest kursor
                    for (const component of allComponents) {
                        if (isPointInElement(mousePoint, component)) {
                            hoveredComponentId = component.getAttribute('data-export-id');
                            component.dataset.interactive = 'true';
                            foundHovered = true;

                            // Zatrzymaj po znalezieniu pierwszego (najwy≈ºszego)
                            break;
                        } else {
                            component.dataset.interactive = 'false';
                        }
                    }

                    // Je≈õli nie znaleziono, wyczy≈õƒá dane
                    if (!foundHovered) {
                        hoveredComponentId = null;
                        allComponents.forEach(comp => comp.dataset.interactive = 'false');
                    }
                }

                // Czekaj na pe≈Çne za≈Çadowanie SVG
                document.addEventListener('DOMContentLoaded', () => {
                    // Naprawa b≈Çƒôdu NaN w transformacjach
                    document.querySelectorAll('[transform]').forEach(el => {
                        const transform = el.getAttribute('transform');
                        if (transform && transform.includes('NaN')) {
                            const fixedTransform = transform.replace(/rotate\\(NaN/g, 'rotate(0');
                            el.setAttribute('transform', fixedTransform);
                        }
                    });

                    // Resetuj inicjalizacjƒô wszystkich komponent√≥w
                    document.querySelectorAll('svg[data-export-id]').forEach(svg => {
                        // Resetuj flagi inicjalizacji, aby skrypty mog≈Çy siƒô ponownie zainicjalizowaƒá
                        svg.removeAttribute('data-gauge-initialized');
                        svg.removeAttribute('data-counter-initialized');
                        svg.removeAttribute('data-toggle-initialized');
                        svg.removeAttribute('data-knob-initialized');
                        svg.removeAttribute('data-slider-initialized');
                        svg.removeAttribute('data-switch-initialized');
                        svg.removeAttribute('data-relay-initialized');
                        svg.removeAttribute('data-button-initialized');

                        // Domy≈õlnie wszystkie komponenty nieinteraktywne
                        svg.dataset.interactive = 'false';

                        // Ustaw zdarzenia dla tego komponentu
                        svg.addEventListener('click', function(e) {
                            // Sprawd≈∫, czy ten komponent jest aktualnie aktywnym
                            if (this.dataset.interactive !== 'true') {
                                e.stopPropagation();
                                e.preventDefault();
                                return false;
                            }
                        }, true);
                    });

                    // Ustaw nas≈Çuchiwanie zdarze≈Ñ na ca≈Çym dokumencie
                    document.addEventListener('mousemove', updateComponentsInteractivity, true);
                    document.addEventListener('mousedown', function(e) {
                        if (hoveredComponentId) {
                            activeComponentId = hoveredComponentId;
                        } else {
                            activeComponentId = null;
                        }
                    }, true);
                    document.addEventListener('mouseup', function() {
                        activeComponentId = null;
                    }, true);

                    // Specjalne obs≈Çuga przycisk√≥w i toggle'a
                    document.querySelectorAll('.toggle-handle, .button-surface, .counter-increment-button, .counter-decrement-button').forEach(el => {
                        el.addEventListener('click', function(e) {
                            const parentSvg = this.closest('svg[data-export-id]');
                            if (!parentSvg || parentSvg.dataset.interactive !== 'true') {
                                e.stopPropagation();
                                e.preventDefault();
                                return false;
                            }
                        }, true);
                    });

                    // Dla ka≈ºdego skryptu w komponentach, dodaj sprawdzanie interactive
                    document.querySelectorAll('svg[data-export-id] script').forEach(script => {
                        const parentSvg = script.closest('svg[data-export-id]');
                        if (parentSvg) {
                            // Dodaj zmiennƒÖ identyfikacyjnƒÖ do ka≈ºdego skryptu
                            const componentId = parentSvg.getAttribute('data-export-id');
                            let scriptContent = script.textContent;

                            // Dodaj sprawdzanie interaktywno≈õci przed inicjalizacjƒÖ
                            scriptContent = scriptContent.replace(
                                '(function() {',
                                `(function() {
                                    // Helper function to check if component is interactive
                                    function isComponentInteractive() {
                                        const mySvg = document.querySelector('svg[data-export-id="\${componentId}"]');
                                        return mySvg && mySvg.dataset.interactive === 'true';
                                    }
                                }`
                            );

                            // Dodaj sprawdzanie w ka≈ºdym event listenerze
                            scriptContent = scriptContent.replace(
                                /addEventListener\(['"](click|mousedown|mousemove|mouseup|mouseover)['"]\s*,\s*function\s*\(([^)]*)\)\s*\{/g,
                                'addEventListener("$1", function($2) { if (!isComponentInteractive()) { e.stopPropagation(); e.preventDefault(); return false; } else {'
                            );

                            scriptContent = scriptContent + "\n}}";

                            script.textContent = scriptContent;
                        }
                    });

                    // Dodaj walidacjƒô w skryptach animacji, aby uniknƒÖƒá b≈Çƒôd√≥w NaN
                    const validateNumeric = (val, defaultVal = 0) => {
                        return (val !== undefined && val !== null && !isNaN(parseFloat(val))) ? parseFloat(val) : defaultVal;
                    };

                    // Udostƒôpnij funkcjƒô globalnie
                    window.validateNumeric = validateNumeric;

                    // Napraw b≈Çƒôdy w animacjach obrot√≥w
                    document.querySelectorAll('.gauge-needle, .knob-indicator').forEach(el => {
                        const originalSetAttribute = el.setAttribute;
                        el.setAttribute = function(attr, val) {
                            if (attr === 'transform' && val.includes('rotate')) {
                                // Sprawd≈∫, czy warto≈õci obrotu sƒÖ poprawne
                                const rotateMatch = val.match(/rotate\\(([^,\\s]+)(?:[\\s,]+([^,\\s]+)[\\s,]+([^\\)\\s]+))?\\)/);
                                if (rotateMatch) {
                                    const angle = validateNumeric(rotateMatch[1]);
                                    const x = validateNumeric(rotateMatch[2], 30);
                                    const y = validateNumeric(rotateMatch[3], 30);
                                    val = \`rotate(\${angle} \${x} \${y})\`;
                                }
                            }
                            return originalSetAttribute.call(this, attr, val);
                        };
                    });

                    // Zainicjuj interaktywno≈õƒá
                    const initialEvent = new MouseEvent('mousemove', {
                        bubbles: true,
                        cancelable: true,
                        view: window,
                        clientX: -1,
                        clientY: -1
                    });
                    document.dispatchEvent(initialEvent);
                })();
            })();
        `;

        tempSvgCanvas.appendChild(scriptNode);

        // Pobierz zawarto≈õƒá SVG
        const svgData = new XMLSerializer().serializeToString(tempSvgCanvas);

        // Utw√≥rz kompletny dokument SVG z przestrzeniƒÖ nazw i skryptami
        const svgDocumentWithScripts = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xlink="http://www.w3.org/1999/xlink"
     xmlns:xhtml="http://www.w3.org/1999/xhtml"
     version="1.1" width="100%" height="100%" viewBox="0 0 1000 800">
     ${svgData}
</svg>`;

        // Utw√≥rz link do pobrania
        const blob = new Blob([svgDocumentWithScripts], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);

        // Utw√≥rz i kliknij link do pobrania
        const a = document.createElement('a');
        a.href = url;
        a.download = 'digital-twin-export.svg';
        document.body.appendChild(a);
        a.click();

        // PosprzƒÖtaj
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
    };

    // --- SYMULACJA DANYCH ---
    window.startSimulation = () => {
        if (simulationInterval) return;

        simulationInterval = setInterval(() => {
            svgCanvas.querySelectorAll("svg[data-id]").forEach(comp => {
                const metadataNode = comp.querySelector("metadata");
                if (!metadataNode) return;

                let metadata;
                try {
                    metadata = JSON.parse(metadataNode.textContent);
                } catch (e) {
                    return;
                }

                const params = metadata.parameters;
                if (!params.isActive) return;

                // Symuluj wszystkie liczbowe parametry
                Object.keys(params).forEach(key => {
                    if (typeof params[key] === "number" && !key.includes("Min") && !key.includes("Max") && key !== "size") {
                        const min = params[`${key}Min`] ?? 0;
                        const max = params[`${key}Max`] ?? 100;
                        const newVal = min + Math.random() * (max - min);
                        params[key] = parseFloat(newVal.toFixed(2));

                        metadataNode.textContent = JSON.stringify(metadata, null, 2);
                        applyParameterToSVG(comp, key, params[key]);

                        const displayEl = document.getElementById(`sim-value-${metadata.id}`);
                        if (displayEl) displayEl.textContent = params[key];
                    }
                });
            });
        }, 1000);
    };

    window.stopSimulation = () => {
        if (simulationInterval) clearInterval(simulationInterval);
        simulationInterval = null;
    };

    function refreshSimulationList() {
        const list = document.getElementById("simulation-list");
        list.innerHTML = "";

        svgCanvas.querySelectorAll("svg[data-id]").forEach(comp => {
            const metadataNode = comp.querySelector("metadata");
            if (!metadataNode) return;

            let metadata;
            try {
                metadata = JSON.parse(metadataNode.textContent);
            } catch (e) {
                return;
            }

            if (metadata.parameters.value !== undefined) {
                const el = document.createElement("p");
                el.innerHTML = `<strong>${metadata.name}</strong>: <span id="sim-value-${metadata.id}">${metadata.parameters.value}</span>`;
                list.appendChild(el);
            }
        });

        if (list.children.length === 0) {
            list.innerHTML = "<p><i>Brak komponent√≥w z parametrem 'value'</i></p>";
        }
    }

    // --- DODAJ PARAMETR ---
    window.addParameter = (id) => {
        const name = prompt("Nazwa parametru (np. pressure):");
        if (!name) return;

        const type = prompt("Typ (string, number, boolean)", "number");
        let value;
        switch (type) {
            case "number":
                value = 0;
                break;
            case "boolean":
                value = false;
                break;
            default:
                value = "nowy";
        }

        const comp = svgCanvas.querySelector(`[data-id="${id}"]`);
        const metadataNode = comp.querySelector("metadata");
        let metadata;

        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            metadata = {id, parameters: {}};
        }

        metadata.parameters[name] = value;
        metadataNode.textContent = JSON.stringify(metadata, null, 2);
        selectComponent(comp);
    };

    // --- PWA ---
    if ("serviceWorker" in navigator) {
        navigator.serviceWorker.register("sw.js").then(() => {
            console.log("SW zarejestrowany");
        });
    }

    function updateMetadataInSVG(svgElement, path, value) {
        // Pobierz metadane
        let metadata = {};
        let metadataNode = svgElement.querySelector('metadata');

        if (metadataNode && metadataNode.textContent.trim()) {
            try {
                metadata = JSON.parse(metadataNode.textContent);
            } catch (e) {
                console.warn('B≈ÇƒÖd parsowania metadanych:', e);
            }
        } else if (!metadataNode) {
            // Je≈õli nie ma wƒôz≈Ça metadanych, utw√≥rz nowy
            metadataNode = document.createElement('metadata');
            svgElement.appendChild(metadataNode);
        }

        // Zaktualizuj warto≈õƒá w ≈õcie≈ºce (np. 'parameters.speed')
        const keys = path.split('.');
        let current = metadata;

        for (let i = 0; i < keys.length - 1; i++) {
            if (current[keys[i]] === undefined) {
                current[keys[i]] = {};
            }
            current = current[keys[i]];
        }

        current[keys[keys.length - 1]] = value;

        // Zapisz zaktualizowane metadane
        metadataNode.textContent = JSON.stringify(metadata, null, 2);

        // Zastosuj zmiany do wizualizacji
        applyParameterToSVG(svgElement, path, value);
    }

    function applyParameterToSVG(svgElement, paramKey, value) {
        if (!svgElement) return;

        // Pobierz metadane
        const metadataNode = svgElement.querySelector('metadata');
        if (!metadataNode) return;

        let metadata;
        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            console.warn('B≈ÇƒÖd parsowania metadanych:', e);
            return;
        }

        // Pobierz typ komponentu i ID z metadanych
        const componentType = metadata.type || 'default';
        const instanceId = svgElement.getAttribute('data-id');
        const params = metadata.parameters || {};

        // Stw√≥rz mapowanie parametr√≥w do element√≥w SVG
        // Format: 'parameters.nazwaParam': ['.klasaElementu', 'atrybut', warto≈õƒáBezpo≈õrednia/funkcja]
        const paramMappings = {
            // Og√≥lne parametry dla wszystkich komponent√≥w
            'parameters.label': ['.knob-label, .button-label, .switch-label, .relay-label, .led-label, .slider-label, .gauge-label, .counter-label, .toggle-label', 'textContent'],
            'parameters.isActive': ['svg', 'data-active'],

            // LED
            'parameters.color': ['.led-core, .knob-body, .slider-progress, .gauge-needle, .toggle-track', 'fill'],

            // Prze≈ÇƒÖcznik
            'parameters.state': [
                // Handler dla state u≈ºywany do transformacji
                (elem, val) => {
                    const switchHandle = elem.querySelector('.switch-handle');
                    const switchTrack = elem.querySelector('.switch-track');
                    const toggleHandle = elem.querySelector('.toggle-handle');
                    const toggleTrack = elem.querySelector('.toggle-track');

                    // Obs≈Çuga prze≈ÇƒÖcznika
                    if (switchHandle && switchTrack) {
                        switchHandle.setAttribute('cx', val ? '27' : '13');
                        switchTrack.setAttribute('fill', val ? (params.color || '#3498db') : '#7f8c8d');
                    }

                    // Obs≈Çuga toggle slider
                    if (toggleHandle && toggleTrack) {
                        toggleHandle.setAttribute('cx', val ? '27' : '13');
                        toggleTrack.setAttribute('fill', val ? (params.color || '#2ecc71') : '#7f8c8d');
                    }

                    // Obs≈Çuga przeka≈∫nika
                    const relayIndicator = elem.querySelector('.relay-indicator');
                    if (relayIndicator) {
                        relayIndicator.setAttribute('fill', val ? (params.color || '#e67e22') : '#7f8c8d');
                    }
                }
            ],

            // Przyciski
            'parameters.pressed': [
                (elem, val) => {
                    const buttonSurface = elem.querySelector('.button-surface');
                    const buttonShadow = elem.querySelector('.button-shadow');

                    if (buttonSurface && buttonShadow) {
                        buttonSurface.setAttribute('cy', val ? '22' : '20');
                        buttonSurface.setAttribute('r', val ? '9' : '10');
                        buttonShadow.setAttribute('opacity', val ? '0.1' : '0.3');

                        // Je≈õli chwilowe, zwolnij przycisk po 300ms
                        if (val && params.momentary) {
                            clearTimeout(elem.releaseTimeout);
                            elem.releaseTimeout = setTimeout(() => {
                                const newMetadata = JSON.parse(metadataNode.textContent);
                                if (newMetadata && newMetadata.parameters) {
                                    newMetadata.parameters.pressed = false;
                                    metadataNode.textContent = JSON.stringify(newMetadata, null, 2);

                                    // Rekursywne wywo≈Çanie do aktualizacji wyglƒÖdu
                                    applyParameterToSVG(elem, 'parameters.pressed', false);
                                }
                            }, 300);
                        }
                    }
                }
            ],

            // Pokrƒôt≈Ço i suwak (warto≈õci numeryczne)
            'parameters.value': [
                (elem, val) => {
                    // Wsp√≥lne zmienne
                    const min = params.min || 0;
                    const max = params.max || 100;
                    const safeVal = Math.min(Math.max(val, min), max);
                    const percentage = (safeVal - min) / (max - min);

                    // Obs≈Çuga pokrƒôt≈Ça
                    const knobIndicator = elem.querySelector('.knob-indicator');
                    const knobValue = elem.querySelector('.knob-value');
                    if (knobIndicator) {
                        const angle = percentage * 270 - 135; // -135¬∞ do +135¬∞
                        knobIndicator.setAttribute('transform', `rotate(${angle} 20 20)`);
                        if (knobValue) knobValue.textContent = safeVal;
                    }

                    // Obs≈Çuga suwaka
                    const sliderHandle = elem.querySelector('.slider-handle');
                    const sliderProgress = elem.querySelector('.slider-progress');
                    const sliderValue = elem.querySelector('.slider-value');
                    if (sliderHandle) {
                        const trackWidth = 40;
                        const startX = 10;
                        const handleX = startX + percentage * trackWidth;

                        sliderHandle.setAttribute('cx', handleX);
                        if (sliderProgress) {
                            sliderProgress.setAttribute('width', percentage * trackWidth);
                        }
                        if (sliderValue) sliderValue.textContent = safeVal;
                    }

                    // Obs≈Çuga licznika
                    const counterValue = elem.querySelector('.counter-value');
                    if (counterValue) {
                        animateCounterValue(counterValue, counterValue.textContent, safeVal);
                    }

                    // Obs≈Çuga miernika
                    const gaugeNeedle = elem.querySelector('.gauge-needle');
                    const gaugeValue = elem.querySelector('.gauge-value');
                    if (gaugeNeedle) {
                        const gaugeAngle = percentage * 180 - 90; // -90¬∞ do +90¬∞
                        // Animuj obr√≥t
                        animateNeedleRotation(gaugeNeedle, gaugeAngle);
                        if (gaugeValue) gaugeValue.textContent = safeVal;
                    }
                }
            ]
        };

        // Funkcja do animacji obrot√≥w ig≈Çy w mierniku
        function animateNeedleRotation(needle, targetAngle) {
            if (!needle) return;

            // Pobierz aktualny kƒÖt z transformacji
            let currentAngle = 0;
            const transform = needle.getAttribute('transform');
            if (transform && transform.includes('rotate')) {
                const match = transform.match(/rotate\\(([^,]+),\\s*([^,]+),\\s*([^\\)]+)\\)/);
                if (match && match[1]) {
                    currentAngle = parseFloat(match[1]);
                }
            }

            // Anuluj poprzedniƒÖ animacjƒô
            if (needle.animation) {
                clearInterval(needle.animation);
            }

            // Ustaw animacjƒô
            const steps = 10;
            const stepDuration = 20;
            const angleDiff = targetAngle - currentAngle;
            let step = 0;

            needle.animation = setInterval(() => {
                step++;
                const progress = step / steps;
                const newAngle = currentAngle + progress * angleDiff;

                needle.setAttribute('transform', `rotate(${newAngle} 30 30)`);

                if (step >= steps) {
                    clearInterval(needle.animation);
                    needle.animation = null;
                }
            }, stepDuration);
        }

        // Funkcja do animacji zmiany warto≈õci licznika
        function animateCounterValue(element, fromValue, toValue) {
            if (!element) return;

            // Konwersja na liczby
            fromValue = parseFloat(fromValue) || 0;
            toValue = parseFloat(toValue);

            // Anuluj poprzedniƒÖ animacjƒô
            if (element.animation) {
                clearInterval(element.animation);
            }

            // Ustawienia animacji
            const steps = 15;
            const stepDuration = 30;
            const valueDiff = toValue - fromValue;
            let step = 0;

            element.animation = setInterval(() => {
                step++;
                const progress = step / steps;
                const newValue = fromValue + progress * valueDiff;

                // Aktualizuj warto≈õƒá z odpowiednim formatowaniem
                element.textContent = Math.round(newValue);

                if (step >= steps) {
                    clearInterval(element.animation);
                    element.animation = null;
                    element.textContent = toValue; // Upewnij siƒô, ≈ºe ko≈Ñcowa warto≈õƒá jest dok≈Çadna
                }
            }, stepDuration);
        }

        // Funkcja do obs≈Çugi migania diody LED
        function handleLedBlinking(ledElement) {
            if (!ledElement) return;

            // Pobierz element jƒÖdra diody
            const ledCore = ledElement.querySelector('.led-core');
            if (!ledCore) return;

            // Zatrzymaj istniejƒÖce miganie
            if (ledElement.blinkInterval) {
                clearInterval(ledElement.blinkInterval);
                ledElement.blinkInterval = null;
            }

            // Ustaw nowy stan
            if (params.isBlinking && params.isOn) {
                let on = true;
                ledElement.blinkInterval = setInterval(() => {
                    ledCore.setAttribute('fill', on ? params.color : '#333');
                    on = !on;
                }, params.blinkRate || 500);
            } else {
                // Ustaw stan sta≈Çy
                ledCore.setAttribute('fill', params.isOn ? params.color : '#333');
            }
        }

        // Aplikuj zmiany parametr√≥w
        const fullParamKey = paramKey.startsWith('parameters.') ? paramKey : `parameters.${paramKey}`;

        // Sprawd≈∫, czy mamy mapowanie dla tego parametru
        if (paramMappings[fullParamKey]) {
            const mapping = paramMappings[fullParamKey];

            if (typeof mapping[0] === 'function') {
                // Funkcja niestandardowa
                mapping[0](svgElement, value);
            } else {
                // Selektor CSS i atrybut
                const elements = svgElement.querySelectorAll(mapping[0]);
                if (elements.length > 0) {
                    elements.forEach(el => {
                        el[mapping[1]] = value;
                    });
                }
            }
        }

        // Specjalna obs≈Çuga dla LED
        if (componentType === 'led' && (fullParamKey === 'parameters.isBlinking' ||
            fullParamKey === 'parameters.isOn' ||
            fullParamKey === 'parameters.color' ||
            fullParamKey === 'parameters.blinkRate')) {
            handleLedBlinking(svgElement);
        }

        // Domy≈õlna obs≈Çuga dla nieznanych typ√≥w i parametr√≥w
        if (fullParamKey.startsWith('parameters.') && !paramMappings[fullParamKey]) {
            // Pr√≥ba znalezienia elementu po ID r√≥wnym nazwie parametru
            const paramName = fullParamKey.split('.')[1];
            const element = svgElement.querySelector(`#${paramName}`);
            if (element) {
                if (typeof value === 'boolean') {
                    element.style.display = value ? 'inline' : 'none';
                } else if (typeof value === 'string' && value.startsWith('#')) {
                    // Prawdopodobnie kolor
                    element.setAttribute('fill', value);
                } else if (typeof value === 'string') {
                    // Prawdopodobnie tekst
                    element.textContent = value;
                } else if (typeof value === 'number') {
                    // Pr√≥ba interpretacji jako warto≈õci
                    element.setAttribute('value', value);
                }
            }
        }
    }

    function updateParam(id, paramKey, value, type) {
        if (type === 'number') value = parseFloat(value);
        if (type === 'boolean') value = value === true || value === 'true';

        const svgElement = document.querySelector(`[data-id="${id}"]`);
        if (!svgElement) return;

        // Aktualizuj metadane
        updateMetadataInSVG(svgElement, `parameters.${paramKey}`, value);

        // Zastosuj zmiany do wizualizacji
        applyParameterToSVG(svgElement, paramKey, value);
    }

    function removeComponent(id) {
        const component = components.get(id);
        if (!component) return;

        // Zatrzymaj wszystkie interwa≈Çy zwiƒÖzane z tym komponentem
        if (component.element.blinkInterval) {
            clearInterval(component.element.blinkInterval);
        }
        if (component.element.pollingInterval) {
            clearInterval(component.element.pollingInterval);
        }

        // Usu≈Ñ element z DOM
        if (component.element && component.element.parentNode) {
            component.element.parentNode.removeChild(component.element);
        }

        // Usu≈Ñ z mapy komponent√≥w
        components.delete(id);

        // Usu≈Ñ po≈ÇƒÖczenia zwiƒÖzane z tym komponentem
        updateConnections(id, true);

        // Wyczy≈õƒá panel w≈Ça≈õciwo≈õci
        const propertiesPanel = document.getElementById('properties-panel');
        if (propertiesPanel) {
            propertiesPanel.style.display = 'none';
        }

        if (selectedComponent && selectedComponent.getAttribute('data-id') === id) {
            selectedComponent = null;
        }
    }

    function editMetadataRaw(id) {
        const el = document.querySelector(`[data-id="${id}"]`);
        const metadataNode = el.querySelector("metadata");
        let metadata;

        try {
            metadata = JSON.parse(metadataNode.textContent);
        } catch (e) {
            alert("B≈ÇƒÖd: niepoprawny JSON w metadanych");
            return;
        }

        const jsonStr = JSON.stringify(metadata, null, 2);
        const newJson = prompt("Edytuj metadane (JSON):", jsonStr);

        if (newJson) {
            try {
                JSON.parse(newJson); // walidacja
                metadataNode.textContent = newJson;
                selectComponent(el); // od≈õwie≈º panel
                alert("Metadane zaktualizowane!");
            } catch (e) {
                alert("B≈ÇƒÖd sk≈Çadni JSON: " + e.message);
            }
        }
    }

    function updatePosition(id, coord, value) {
        const el = document.querySelector(`[data-id="${id}"]`);
        if (!el) return;

        const numValue = parseFloat(value);
        if (isNaN(numValue)) return;

        const currentX = parseFloat(el.getAttribute("x"));
        const currentY = parseFloat(el.getAttribute("y"));
        const size = el.querySelector("metadata") ?
            JSON.parse(el.querySelector("metadata").textContent).parameters?.size || 50 : 50;

        // Oblicz nowƒÖ pozycjƒô kontenera
        if (coord === "x") {
            el.setAttribute("x", numValue - size / 2);
        } else {
            el.setAttribute("y", numValue - size / 2);
        }

        // Aktualizuj metadane
        const metadataNode = el.querySelector("metadata");
        if (metadataNode) {
            let metadata;
            try {
                metadata = JSON.parse(metadataNode.textContent);
            } catch (e) {
                return;
            }
            metadata.position[coord] = Math.round(numValue);
            metadataNode.textContent = JSON.stringify(metadata, null, 2);
        }

        // Od≈õwie≈º panel (≈ºeby zobaczyƒá zmianƒô)
        showProperties(el);
    };

    // Za≈Çaduj komponenty do biblioteki z ikonami
    async function loadComponentLibrary() {
        const container = document.getElementById("component-library");
        if (!container) {
            console.error("Nie znaleziono kontenera biblioteki komponent√≥w (component-library)");
            return;
        }

        container.innerHTML = ""; // wyczy≈õƒá

        for (const comp of COMPONENTS) {
            try {
                const response = await fetch(comp.svg);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const svgText = await response.text();
                if (!svgText || !svgText.trim().startsWith('<svg') && !svgText.trim().startsWith('<?xml')) {
                    throw new Error("Nieprawid≈Çowy format SVG");
                }

                const parser = new DOMParser();
                const svgDoc = parser.parseFromString(svgText, "image/svg+xml");

                // Sprawd≈∫ b≈Çƒôdy parsowania
                const parserError = svgDoc.querySelector("parsererror");
                if (parserError) {
                    throw new Error("B≈ÇƒÖd parsowania SVG");
                }

                const svgElement = svgDoc.documentElement;
                if (!svgElement || svgElement.nodeName !== 'svg') {
                    throw new Error("Nie znaleziono elementu SVG");
                }

                // Przygotuj SVG jako ikona - u≈ºywamy setAttribute zamiast style
                svgElement.setAttribute("width", "32");
                svgElement.setAttribute("height", "32");
                svgElement.removeAttribute("id");

                // U≈ºywamy setAttribute zamiast style.display
                svgElement.setAttribute("style", "display: block;");

                // Tworzymy przycisk
                const button = document.createElement("button");
                button.className = "component-button";
                button.draggable = true;
                button.dataset.svg = comp.svg;
                button.title = comp.name;

                // Ikona po lewej
                const iconWrapper = document.createElement("div");
                iconWrapper.setAttribute("style", "width: 36px; height: 36px; flex-shrink: 0;");
                iconWrapper.appendChild(svgElement);

                // Tekst
                const label = document.createElement("span");
                label.textContent = comp.name;

                // Dodaj do przycisku
                button.appendChild(iconWrapper);
                button.appendChild(label);

                // Obs≈Çuga przeciƒÖgania
                button.addEventListener("dragstart", (e) => {
                    e.dataTransfer.setData("text/plain", comp.svg);
                });

                container.appendChild(button);
            } catch (err) {
                console.error(`B≈ÇƒÖd ≈Çadowania ikony ${comp.svg}:`, err);
                const fallbackButton = document.createElement("button");
                fallbackButton.className = "component-button";
                fallbackButton.draggable = true;
                fallbackButton.dataset.svg = comp.svg;
                fallbackButton.innerHTML = `<span>‚ö†Ô∏è ${comp.name}</span>`;
                fallbackButton.title = "B≈ÇƒÖd ≈Çadowania ikony";

                // Sprawd≈∫ czy kontener istnieje przed dodaniem przycisku awaryjnego
                const componentLibrary = document.getElementById("component-library");
                if (componentLibrary) {
                    componentLibrary.appendChild(fallbackButton);
                }
            }
        }
    }

    // Uruchom po za≈Çadowaniu DOM
    document.addEventListener("DOMContentLoaded", loadComponentLibrary);
</script>
</body>
</html>
