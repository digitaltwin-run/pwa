<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" width="60" height="60" viewBox="0 0 60 60" data-component-params="label,value,min,max,units,isactive,color,ison,isblinking,blinkrate">

    <title>Gauge Component</title>
    <desc>Interactive gauge/meter component with animated needle movement for digital twin</desc>

    <metadata>
        <component id="gauge-001" name="Analog Gauge" type="gauge">
            <parameters>
                <label>Gauge</label>
                <value>50</value>
                <min>0</min>
                <max>100</max>
                <units>%</units>
                <isActive>true</isActive>
            <color>#e74c3c</color><ison>false</ison><isblinking>false</isblinking><blinkrate>500</blinkrate></parameters>
        </component>
    </metadata>


    <!-- Background -->
    <circle class="gauge-background" cx="30" cy="30" r="28" fill="#34495e" stroke="#2c3e50" stroke-width="2"/>

    <!-- Gauge face -->
    <circle class="gauge-face" cx="30" cy="30" r="24" fill="#ecf0f1" stroke="#bdc3c7" stroke-width="1"/>

    <!-- Scale markings -->
    <path class="gauge-scale" d="M 18 42 A 18 18 0 0 1 42 42" stroke="#7f8c8d" stroke-width="1" fill="none"/>

    <!-- Scale marks -->
    <line x1="30" y1="30" x2="30" y2="14" stroke="#7f8c8d" stroke-width="0.5" transform="rotate(0 30 30)"/>
    <line x1="30" y1="30" x2="30" y2="14" stroke="#7f8c8d" stroke-width="0.5" transform="rotate(45 30 30)"/>
    <line x1="30" y1="30" x2="30" y2="14" stroke="#7f8c8d" stroke-width="0.5" transform="rotate(90 30 30)"/>
    <line x1="30" y1="30" x2="30" y2="14" stroke="#7f8c8d" stroke-width="0.5" transform="rotate(135 30 30)"/>
    <line x1="30" y1="30" x2="30" y2="14" stroke="#7f8c8d" stroke-width="0.5" transform="rotate(180 30 30)"/>

    <!-- Min and Max labels -->
    <text x="15" y="42" font-size="6" text-anchor="middle" fill="#2c3e50">0</text>
    <text x="45" y="42" font-size="6" text-anchor="middle" fill="#2c3e50">100</text>

    <!-- Needle -->
    <g class="gauge-needle" transform="rotate(0 30 30)">
        <line x1="30" y1="30" x2="30" y2="14" stroke="#e74c3c" stroke-width="2" stroke-linecap="round"/>
        <circle cx="30" cy="30" r="3" fill="#2c3e50"/>
    </g>

    <!-- Value display -->
    <text class="gauge-value" x="30" y="48" font-size="10" text-anchor="middle" fill="#2c3e50">50%</text>

    <!-- Label -->
    <text class="gauge-label" x="30" y="56" font-size="8" text-anchor="middle" fill="#bdc3c7">Gauge</text>

    <defs>
    <!-- Wewnętrzny skrypt SVG -->
    <script><![CDATA[
      (function() {
        // Function to read metadata
        function getMetadata(svgElement) {
          const metadataElement = svgElement.querySelector('metadata component');
          if (metadataElement) {
            try {
              const parametersElement = metadataElement.querySelector('parameters');
              if (parametersElement) {
                const result = {
                  parameters: {
                    label: parametersElement.querySelector('label')?.textContent || 'Gauge',
                    value: parseFloat(parametersElement.querySelector('value')?.textContent || '50'),
                    min: parseFloat(parametersElement.querySelector('min')?.textContent || '0'),
                    max: parseFloat(parametersElement.querySelector('max')?.textContent || '100'),
                    color: parametersElement.querySelector('color')?.textContent || '#e74c3c',
                    units: parametersElement.querySelector('units')?.textContent || '%',
                    isActive: parametersElement.querySelector('isActive')?.textContent === 'true'
                  }
                };
                return result;
              }
            } catch (e) {
              console.warn('Error parsing metadata:', e);
            }
          }
          return {};
        }

        // Function to update gauge appearance
        function updateGauge(svgElement) {
          const metadata = getMetadata(svgElement);
          const params = metadata.parameters || {};

          const gaugeNeedle = svgElement.querySelector('.gauge-needle');
          const gaugeValue = svgElement.querySelector('.gauge-value');
          const labelEl = svgElement.querySelector('.gauge-label');

          if (!gaugeNeedle || params.isActive === false) {
            return;
          }

          // Update label
          if (labelEl && params.label) {
            labelEl.textContent = params.label;
          }

          // Calculate angle based on value, min and max
          const min = params.min || 0;
          const max = params.max || 100;
          const value = Math.min(Math.max(params.value, min), max);
          const percentage = (value - min) / (max - min);
          const angle = percentage * 180 - 90; // -90° to +90° rotation

          // Get current angle
          let currentAngle = 0;
          const transform = gaugeNeedle.getAttribute('transform');
          if (transform && transform.includes('rotate')) {
            const match = transform.match(/rotate\(([^,]+)/);
            if (match && match[1]) {
              currentAngle = parseFloat(match[1]);
            }
          }

          // Animate the needle rotation
          animateNeedleRotation(gaugeNeedle, currentAngle, angle);

          // Update value text
          if (gaugeValue) {
            gaugeValue.textContent = value + (params.units || '');
          }

          // Update needle color if specified
          const needleLine = gaugeNeedle.querySelector('line');
          if (needleLine && params.color) {
            needleLine.setAttribute('stroke', params.color);
          }
        }

        // Function to animate needle rotation
        function animateNeedleRotation(needle, fromAngle, toAngle) {
          if (!needle) return;

          // Cancel previous animation
          if (needle.animation) {
            clearInterval(needle.animation);
          }

          // Animation settings
          const steps = 10;
          const stepDuration = 20;
          const angleDiff = toAngle - fromAngle;
          let step = 0;

          needle.animation = setInterval(() => {
            step++;
            const progress = step / steps;
            const newAngle = fromAngle + progress * angleDiff;

            needle.setAttribute('transform', `rotate(${newAngle} 30 30)`);

            if (step >= steps) {
              clearInterval(needle.animation);
              needle.animation = null;
            }
          }, stepDuration);
        }

        // Function to update metadata value
        function updateMetadataValue(svgElement, newValue) {
          const metadataElement = svgElement.querySelector('metadata component');
          if (metadataElement) {
            const valueElement = metadataElement.querySelector('parameters value');
            if (valueElement) {
              valueElement.textContent = newValue.toString();
              return true;
            }
          }
          return false;
        }

        // Initialize
        // Initialize - bardziej odporna metoda znajdowania elementu SVG
        // Najpierw spróbuj standardową metodę (działa w IDE)
        let svgElement = document.currentScript ? document.currentScript.closest('svg') : null;

        // Jeśli nie znaleziono (np. w wyeksportowanym pliku), spróbuj znaleźć wszystkie SVG
        // i wybierz ten, który zawiera ten skrypt
        if (!svgElement) {
            // Pobierz wszystkie elementy SVG w dokumencie
            const allSvgs = document.querySelectorAll('svg');

            // Przeszukaj wszystkie SVG i znajdź ten z wskaźnikiem
            for (const svg of allSvgs) {
                if (svg.querySelector('.gauge-face') && svg.querySelector('.gauge-needle')) {
                    svgElement = svg;
                    break;
                }
            }
        }

        if (svgElement && !svgElement.hasAttribute('data-gauge-initialized')) {
          svgElement.setAttribute('data-gauge-initialized', 'true');

          // Store a unique identifier for this gauge
          svgElement.gaugeInstanceId = 'gauge-' + Math.random().toString(36).substr(2, 9);

          // Initial update
          updateGauge(svgElement);

          // Handle click interaction
          svgElement.addEventListener('click', (e) => {
            // Get current metadata
            const metadata = getMetadata(svgElement);
            if (!metadata.parameters) return;

            // Calculate relative click position in gauge
            const bbox = svgElement.getBoundingClientRect();
            const cx = bbox.width / 2;
            const cy = bbox.height / 2;

            // Get click coordinates relative to center
            const clickX = (e.clientX - bbox.left - cx) * (60 / bbox.width);
            const clickY = (e.clientY - bbox.top - cy) * (60 / bbox.height);

            // Calculate angle from click position
            let angle = Math.atan2(clickY, clickX) * 180 / Math.PI;

            // Adjust angle to fit gauge range (bottom half only)
            if (angle < -90) angle = -90;
            if (angle > 90) angle = 90;

            // Convert angle to value
            const min = metadata.parameters.min || 0;
            const max = metadata.parameters.max || 100;
            const percentage = (angle + 90) / 180;
            const newValue = Math.round(min + percentage * (max - min));

            // Update metadata
            if (updateMetadataValue(svgElement, newValue)) {
              // Update gauge display
              updateGauge(svgElement);
            }
          });

          // Poll for changes
          svgElement.pollingInterval = setInterval(() => {
            // Safely check if element is still in DOM
            if (!svgElement.isConnected) {
              // Clean up if it's been removed
              if (svgElement.pollingInterval) clearInterval(svgElement.pollingInterval);
              if (svgElement.animation) clearInterval(svgElement.animation);
              return;
            }

            const metadata = getMetadata(svgElement);
            const params = metadata.parameters || {};

            // Initialize currentParams if needed
            if (!svgElement.currentParams) {
              svgElement.currentParams = {};
            }

            // Check if parameters have changed
            const hasChanged =
              params.value !== svgElement.currentParams.value ||
              params.color !== svgElement.currentParams.color ||
              params.units !== svgElement.currentParams.units ||
              params.min !== svgElement.currentParams.min ||
              params.max !== svgElement.currentParams.max ||
              params.isActive !== svgElement.currentParams.isActive ||
              params.label !== svgElement.currentParams.label;

            if (hasChanged) {
              svgElement.currentParams = { ...params };
              updateGauge(svgElement);
            }
          }, 500);
        }
      })();
    ]]></script>
    </defs>
</svg>