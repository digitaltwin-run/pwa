<?xml version="1.0" encoding="UTF-8"?>
<svg width="100" height="100" viewBox="0 0 40 40" xmlns="http://www.w3.org/2000/svg">
  <!-- Component Metadata -->
  <metadata>
    <component id="button-001" name="Round Button" type="button">
      <parameters>
        <label>Button</label>
        <pressed>false</pressed>
        <color>#3498db</color>
        <size>40</size>
        <momentary>true</momentary>
        <isActive>true</isActive>
      </parameters>
      <interactions>
        <binding targetId="motor-001" event="press" action="start" />
        <binding targetId="motor-001" event="release" action="stop" />
      </interactions>
    </component>
  </metadata>

  <!-- Button Background -->
  <circle cx="20" cy="20" r="15" fill="#3498db" stroke="#2980b9" stroke-width="1.5" class="button-bg"/>
  
  <!-- Button Label -->
  <text x="50%" y="55%" 
        font-family="Arial, sans-serif" 
        font-size="10" 
        font-weight="bold" 
        text-anchor="middle" 
        fill="white"
        class="button-label">Button</text>

  <!-- Interaction Script -->
  <script>
  <![CDATA[
  (function() {
    const svg = document.currentScript.closest('svg');
    const buttonBg = svg.querySelector('.button-bg');
    const buttonLabel = svg.querySelector('.button-label');

    function getMetadata(svgElement) {
      const metadata = {
        id: 'button-001',
        name: 'Round Button',
        type: 'button',
        parameters: {
          label: 'Button',
          pressed: false,
          color: '#3498db',
          size: 40,
          momentary: true,
          isActive: true
        }
      };

      try {
        // Try to get metadata from SVG element
        const metadataElement = svgElement.querySelector('metadata component');
        if (metadataElement) {
          metadata.id = metadataElement.getAttribute('id') || metadata.id;
          metadata.name = metadataElement.getAttribute('name') || metadata.name;
          metadata.type = metadataElement.getAttribute('type') || metadata.type;

          // Get parameters
          const params = metadataElement.querySelector('parameters');
          if (params) {
            const labelEl = params.querySelector('label');
            if (labelEl) metadata.parameters.label = labelEl.textContent;
            
            const pressedEl = params.querySelector('pressed');
            if (pressedEl) metadata.parameters.pressed = pressedEl.textContent === 'true';
            
            const colorEl = params.querySelector('color');
            if (colorEl) metadata.parameters.color = colorEl.textContent;
            
            const sizeEl = params.querySelector('size');
            if (sizeEl) metadata.parameters.size = parseInt(sizeEl.textContent, 10) || 40;
            
            const momentaryEl = params.querySelector('momentary');
            if (momentaryEl) metadata.parameters.momentary = momentaryEl.textContent === 'true';
            
            const isActiveEl = params.querySelector('isActive');
            if (isActiveEl) metadata.parameters.isActive = isActiveEl.textContent === 'true';
          }
        }
      } catch (e) {
        console.warn('Error parsing metadata:', e);
      }

      return metadata;
    }

    function updateButton() {
      const metadata = getMetadata(svg);
      const params = metadata.parameters || {};

      if (!params.isActive) {
        // If button is not active, make it semi-transparent
        buttonBg.setAttribute('opacity', '0.5');
        return;
      }

      // Update button appearance
      buttonBg.setAttribute('opacity', '1');
      buttonBg.setAttribute('fill', params.pressed ? '#2980b9' : params.color); // Darker shade for pressed state
      buttonLabel.textContent = params.label || 'Button';
      
      // Update button size
      const size = params.size || 40;
      svg.setAttribute('width', size);
      svg.setAttribute('height', size);
      svg.setAttribute('viewBox', `0 0 ${size} ${size}`);
      
      // Adjust button elements for new size
      const radius = (size / 2) * 0.75; // 75% of half the size
      buttonBg.setAttribute('cx', size / 2);
      buttonBg.setAttribute('cy', size / 2);
      buttonBg.setAttribute('r', radius);
      
      // Adjust text size and position
      const fontSize = Math.max(8, size * 0.25);
      buttonLabel.setAttribute('font-size', fontSize);
      buttonLabel.setAttribute('x', '50%');
      buttonLabel.setAttribute('y', '55%');
    }

    // Initial setup
    updateButton();

    // Handle button press/release
    function handleButtonPress() {
      const metadata = getMetadata(svg);
      const params = metadata.parameters || {};
      
      if (params.momentary) {
        // For momentary button, show pressed state while mouse is down
        buttonBg.setAttribute('fill', '#2980b9'); // Darker shade for pressed state
      } else {
        // For toggle button, toggle the pressed state
        params.pressed = !params.pressed;
        updateButton();
      }
      
      // Trigger press event for the IDE to handle
      svg.dispatchEvent(new CustomEvent('componentEvent', {
        detail: {
          componentId: metadata.id,
          event: 'press',
          data: { pressed: true }
        },
        bubbles: true
      }));
    }

    function handleButtonRelease() {
      const metadata = getMetadata(svg);
      const params = metadata.parameters || {};

      if (params.momentary) {
        // For momentary button, return to normal state on release
        buttonBg.setAttribute('fill', params.color);
      }
      
      // Trigger release event for the IDE to handle
      svg.dispatchEvent(new CustomEvent('componentEvent', {
        detail: {
          componentId: metadata.id,
          event: 'release',
          data: { pressed: false }
        },
        bubbles: true
      }));
    }

    // Add event listeners
    svg.addEventListener('mousedown', handleButtonPress);
    svg.addEventListener('mouseup', handleButtonRelease);
    svg.addEventListener('mouseleave', handleButtonRelease);

    // Set up polling for metadata changes
    const pollInterval = setInterval(updateButton, 500);

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      clearInterval(pollInterval);
      svg.removeEventListener('mousedown', handleButtonPress);
      svg.removeEventListener('mouseup', handleButtonRelease);
      svg.removeEventListener('mouseleave', handleButtonRelease);
    });

    // Handle component removal
    try {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (Array.from(mutation.removedNodes).includes(svg)) {
            // Component was removed from DOM, clean up
            clearInterval(pollInterval);
            observer.disconnect();
          }
        });
      });

      if (svg.parentNode) {
        observer.observe(svg.parentNode, { childList: true });
      }
    } catch (e) {
      console.warn('Could not set up removal observer:', e);
    }
  })();
  ]]>
  </script>
</svg>
