<?xml version="1.0" encoding="UTF-8"?>
<svg width="100" height="100" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg" data-component-params="label,pressed,size,momentary,isactive,color,ison,isblinking,blinkrate">
  <!-- Component Metadata -->
  <metadata>
    <component id="button-square-001" name="Square Button" type="button">
      <parameters>
        <label>Button 2</label>
        <pressed>false</pressed>
        <size>100</size>
        <momentary>true</momentary>
        <isActive>true</isActive>
      <color>#e74c3c</color><ison>false</ison><isblinking>false</isblinking><blinkrate>500</blinkrate></parameters>
    </component>
  </metadata>

  <!-- Button Background -->
  <rect id="button-bg" x="5" y="5" width="90" height="90" rx="10" ry="10" fill="#4CAF50" stroke="#2E7D32" stroke-width="2" class="button-bg"/>

  <!-- Button Label -->
  <text x="50%" y="58%" font-family="Arial, sans-serif" font-size="14" font-weight="bold" text-anchor="middle" fill="white" class="button-label">Button 2</text>

  <!-- Interaction Script -->
  <script>
  <![CDATA[
  (function() {
    const svg = document.currentScript.closest('svg');
    const buttonBg = svg.querySelector('.button-bg');
    const buttonLabel = svg.querySelector('.button-label');

    function getMetadata(svgElement) {
      const metadata = {
        id: 'button-square-001',
        name: 'Square Button',
        type: 'button',
        parameters: {
          label: 'Button 2',
          pressed: false,
          color: '#9b59b6',
          size: 100,
          momentary: true,
          isActive: true
        }
      };

      try {
        const metadataElement = svgElement.querySelector('metadata component');
        if (metadataElement) {
          // Get component attributes
          metadata.id = metadataElement.getAttribute('id') || metadata.id;
          metadata.name = metadataElement.getAttribute('name') || metadata.name;
          metadata.type = metadataElement.getAttribute('type') || metadata.type;

          // Get parameters
          const params = metadataElement.querySelector('parameters');
          if (params) {
            Array.from(params.children).forEach(param => {
              const value = param.textContent.trim();
              if (value === 'true' || value === 'false') {
                metadata.parameters[param.tagName] = value === 'true';
              } else if (!isNaN(value) && value.trim() !== '') {
                metadata.parameters[param.tagName] = Number(value);
              } else {
                metadata.parameters[param.tagName] = value;
              }
            });
          }
        }
      } catch (e) {
        console.warn('Error parsing metadata:', e);
      }

      return metadata;
    }

    function updateButton() {
      const metadata = getMetadata(svg);
      const params = metadata.parameters || {};

      if (!params.isActive) {
        // If button is not active, make it semi-transparent
        buttonBg.setAttribute('opacity', '0.5');
        return;
      }

      // Update button appearance
      buttonBg.setAttribute('opacity', '1');
      buttonBg.setAttribute('fill', params.pressed ? '#8e44ad' : params.color); // Darker shade for pressed state
      buttonLabel.textContent = params.label || 'Button 2';

      // Update button size
      const size = params.size || 100;
      svg.setAttribute('width', size);
      svg.setAttribute('height', size);
      svg.setAttribute('viewBox', `0 0 ${size} ${size}`);

      // Adjust button elements for new size
      const padding = size * 0.05;
      const cornerRadius = size * 0.1;
      buttonBg.setAttribute('x', padding);
      buttonBg.setAttribute('y', padding);
      buttonBg.setAttribute('width', size - (padding * 2));
      buttonBg.setAttribute('height', size - (padding * 2));
      buttonBg.setAttribute('rx', cornerRadius);
      buttonBg.setAttribute('ry', cornerRadius);

      // Adjust text size and position
      const fontSize = Math.max(12, size * 0.14);
      buttonLabel.setAttribute('font-size', fontSize);
      buttonLabel.setAttribute('y', size * 0.58);
    }

    // Initial setup
    updateButton();

    // Handle button press/release
    function handleButtonPress() {
      const metadata = getMetadata(svg);
      const params = metadata.parameters || {};

      if (params.momentary) {
        // For momentary button, show pressed state while mouse is down
        buttonBg.setAttribute('fill', '#8e44ad'); // Darker shade for pressed state
      } else {
        // For toggle button, toggle the pressed state
        params.pressed = !params.pressed;
        updateButton();
      }
    }

    function handleButtonRelease() {
      const metadata = getMetadata(svg);
      const params = metadata.parameters || {};

      if (params.momentary) {
        // For momentary button, return to normal state on release
        buttonBg.setAttribute('fill', params.color);
      }

      // Trigger click event for the IDE to handle
      svg.dispatchEvent(new CustomEvent('componentClick', {
        detail: {
          componentId: svg.getAttribute('data-component-id') || 'button2',
          type: 'button',
          state: {
            pressed: params.pressed
          }
        },
        bubbles: true
      }));
    }

    // Add event listeners
    svg.addEventListener('mousedown', handleButtonPress);
    svg.addEventListener('mouseup', handleButtonRelease);
    svg.addEventListener('mouseleave', handleButtonRelease);

    // Set up polling for metadata changes
    const pollInterval = setInterval(updateButton, 500);

    // Cleanup on unload
    window.addEventListener('beforeunload', () => {
      clearInterval(pollInterval);
      svg.removeEventListener('mousedown', handleButtonPress);
      svg.removeEventListener('mouseup', handleButtonRelease);
      svg.removeEventListener('mouseleave', handleButtonRelease);
    });

    // Handle component removal
    try {
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          if (Array.from(mutation.removedNodes).includes(svg)) {
            clearInterval(pollInterval);
            svg.removeEventListener('mousedown', handleButtonPress);
            svg.removeEventListener('mouseup', handleButtonRelease);
            svg.removeEventListener('mouseleave', handleButtonRelease);
            observer.disconnect();
          }
        });
      });

      if (svg.parentNode) {
        observer.observe(svg.parentNode, { childList: true });
      }
    } catch (e) {
      console.warn("Could not set up observer:", e);
    }
  })();
  ]]>
  </script>
</svg>