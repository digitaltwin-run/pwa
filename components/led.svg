<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xhtml="http://www.w3.org/1999/xhtml"
     width="40"
     height="40"
     viewBox="0 0 40 40">

    <title>LED Component - Digital Twin</title>
    <desc>Interactive LED indicator with configurable colors, blinking effects, and states for digital twin interfaces</desc>

    <metadata>
        <component id="led-001" name="Animated LED" type="led">
            <parameters>
                <label>LED</label>
                <color>#e74c3c</color>
                <isOn>true</isOn>
                <isBlinking>true</isBlinking>
                <blinkRate>500</blinkRate>
                <isActive>true</isActive>
            </parameters>
        </component>
    </metadata>


    <!-- Obudowa -->
    <circle class="led-border" cx="20" cy="20" r="18" fill="#2c3e50" stroke="#1a252f" stroke-width="2"/>

    <!-- Diody (wewnętrzny ID) -->
    <circle class="led-core" cx="20" cy="20" r="12" fill="#555"/>

    <!-- Etykieta -->
    <text class="led-label" x="20" y="36" font-size="10" text-anchor="middle" fill="#bdc3c7">LED</text>
    <defs>
    <!-- Wewnętrzny skrypt SVG -->
    <script><![CDATA[
      (function() {
        // Function to read metadata
        function getMetadata(svgElement) {
          const metadataElement = svgElement.querySelector('metadata component');
          if (metadataElement) {
            try {
              const parametersElement = metadataElement.querySelector('parameters');
              if (parametersElement) {
                const result = {
                  parameters: {
                    label: parametersElement.querySelector('label')?.textContent || 'LED',
                    color: parametersElement.querySelector('color')?.textContent || '#e74c3c',
                    isOn: parametersElement.querySelector('isOn')?.textContent === 'true',
                    isBlinking: parametersElement.querySelector('isBlinking')?.textContent === 'true',
                    blinkRate: parseInt(parametersElement.querySelector('blinkRate')?.textContent || '500'),
                    isActive: parametersElement.querySelector('isActive')?.textContent === 'true'
                  }
                };
                return result;
              }
            } catch (e) {
              console.warn('Error parsing metadata:', e);
            }
          }
          return {};
        }

        // Function to update appearance
        function updateLED(svgElement) {
          const metadata = getMetadata(svgElement);
          console.log('Metadane:', metadata);

          const params = metadata.parameters || {};
          const ledCore = svgElement.querySelector('.led-core');
          const labelEl = svgElement.querySelector('.led-label');

          if (!ledCore || params.isActive === false) {
            if (ledCore) ledCore.setAttribute('fill', '#333');
            return;
          }

          // Update label
          if (labelEl && params.label) {
            labelEl.textContent = params.label;
          }

          // Handle blinking
          if (params.isBlinking && params.isOn) {
            // Stop existing blink interval to avoid multiple intervals
            if (svgElement.blinkInterval) {
              clearInterval(svgElement.blinkInterval);
              svgElement.blinkInterval = null;
            }

            // Create a new interval for this LED
            let on = true;
            svgElement.blinkInterval = setInterval(() => {
              if (ledCore) { // Check if element still exists
                ledCore.setAttribute('fill', on ? params.color : '#333');
                on = !on;
              } else {
                // If element was removed, stop interval
                clearInterval(svgElement.blinkInterval);
                svgElement.blinkInterval = null;
              }
            }, params.blinkRate || 500);
          } else {
            // Stop blinking
            if (svgElement.blinkInterval) {
              clearInterval(svgElement.blinkInterval);
              svgElement.blinkInterval = null;
            }
            // Set solid state
            ledCore.setAttribute('fill', params.isOn ? params.color : '#333');
          }
        }

        // Toggle LED function
        function toggleLED(svgElement) {
          const metadataElement = svgElement.querySelector('metadata component');
          if (metadataElement) {
            const isOnElement = metadataElement.querySelector('parameters isOn');
            if (isOnElement) {
              // Toggle the state
              const currentState = isOnElement.textContent === 'true';
              isOnElement.textContent = currentState ? 'false' : 'true';

              // Update appearance immediately
              updateLED(svgElement);
            }
          }
        }

        // Initialize - bardziej odporna metoda znajdowania elementu SVG
        // Najpierw spróbuj standardową metodę (działa w IDE)
        let svgElement = document.currentScript ? document.currentScript.closest('svg') : null;

        // Jeśli nie znaleziono (np. w wyeksportowanym pliku), spróbuj znaleźć wszystkie SVG
        // i wybierz ten, który zawiera ten skrypt
        if (!svgElement) {
            // Pobierz wszystkie elementy SVG w dokumencie
            const allSvgs = document.querySelectorAll('svg');

            // Przeszukaj wszystkie SVG i znajdź ten z diodą LED
            for (const svg of allSvgs) {
                if (svg.querySelector('.led-core') && svg.querySelector('.led-label')) {
                    svgElement = svg;
                    break;
                }
            }
        }

        if (svgElement && !svgElement.hasAttribute('data-led-initialized')) {
          svgElement.setAttribute('data-led-initialized', 'true');

          // Store a unique identifier for this LED
          svgElement.ledInstanceId = 'led-' + Math.random().toString(36).substr(2, 9);

          // Add click event listener to toggle LED
          const ledCore = svgElement.querySelector('.led-core');
          if (ledCore) {
            ledCore.addEventListener('click', function(e) {
              toggleLED(svgElement);
              e.stopPropagation(); // Prevent event bubbling
            });
          }

          // Initial update
          updateLED(svgElement);

          // Optional: listen for changes (if IDE overwrites metadata)
          // Simulate an "observer" - check for changes every 500ms
          svgElement.pollingInterval = setInterval(() => {
            // Safely check if element is still in DOM
            if (!svgElement.isConnected) {
              // Clean up if it's been removed
              if (svgElement.blinkInterval) clearInterval(svgElement.blinkInterval);
              if (svgElement.pollingInterval) clearInterval(svgElement.pollingInterval);
              return;
            }

            const metadata = getMetadata(svgElement);
            const params = metadata.parameters || {};

            // Initialize currentParams if needed
            if (!svgElement.currentParams) {
              svgElement.currentParams = {};
            }

            // Check if parameters have changed
            const hasChanged =
              params.color !== svgElement.currentParams.color ||
              params.isBlinking !== svgElement.currentParams.isBlinking ||
              params.isOn !== svgElement.currentParams.isOn ||
              params.isActive !== svgElement.currentParams.isActive ||
              params.label !== svgElement.currentParams.label ||
              params.blinkRate !== svgElement.currentParams.blinkRate;

            if (hasChanged) {
              svgElement.currentParams = { ...params };
              updateLED(svgElement);
            }
          }, 500);

          // Cleanup on removal or unload
          function cleanupLED() {
            if (svgElement.blinkInterval) clearInterval(svgElement.blinkInterval);
            if (svgElement.pollingInterval) clearInterval(svgElement.pollingInterval);
          }

          window.addEventListener('beforeunload', cleanupLED);

          // For SVGs that are embedded and might be removed
          if (typeof MutationObserver === 'function') {
            try {
              const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                  if (Array.from(mutation.removedNodes).some(node =>
                      node === svgElement || (node.contains && node.contains(svgElement)))) {
                    cleanupLED();
                    observer.disconnect();
                  }
                });
              });

              // Only observe if the SVG is in a document and has a parent node
              if (svgElement.parentNode) {
                observer.observe(svgElement.parentNode, { childList: true });
              }
            } catch (e) {
              // Ignore errors for standalone SVGs
              console.warn("Could not set up observer:", e);
            }
          }
        }
      })();
  ]]></script>
    </defs>
</svg>
