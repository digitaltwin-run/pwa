<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg"
     xmlns:xhtml="http://www.w3.org/1999/xhtml"
     width="40"
     height="40"
     viewBox="0 0 40 40">

    <title>REST API Client - Interactive HTTP Request Interface</title>
    <desc>A PHP-powered SVG interface for making REST API requests with customizable HTTP methods and request bodies</desc>

    <script type="application/json" class="metadata">{
        "id": "led-001",
        "name": "Animated LED",
        "type": "led",
        "parameters": {
            "label": "LED",
            "color": "#e74c3c",
            "isOn": true,
            "isBlinking": true,
            "blinkRate": 500,
            "isActive": true
            }
        }</script>

    <!-- Obudowa -->
    <circle cx="20" cy="20" r="18" fill="#2c3e50" stroke="#1a252f" stroke-width="2"/>

    <!-- Diody (wewnętrzny ID) -->
    <circle class="led-core" cx="20" cy="20" r="12" fill="#555"/>

    <!-- Etykieta -->
    <text class="led-label" x="20" y="36" font-size="10" text-anchor="middle" fill="#bdc3c7">LED</text>
    <defs>
    <!-- Wewnętrzny skrypt SVG -->
    <script><![CDATA[
      (function() {
        // Function to read metadata
        function getMetadata(svgElement) {
          const metadataNode = svgElement.querySelector('script[type="application/json"][class="metadata"]');
          if (metadataNode && metadataNode.textContent.trim()) {
            try {
              return JSON.parse(metadataNode.textContent);
            } catch (e) {
              console.warn('Error parsing metadata:', e);
              return {};
            }
          }
          return {};
        }

        // Function to update appearance
        function updateLED(svgElement) {
          const metadata = getMetadata(svgElement);
          console.log('Metadane:', metadata);

          const params = metadata.parameters || {};
          const ledCore = svgElement.querySelector('.led-core');
          const labelEl = svgElement.querySelector('.led-label');

          if (!ledCore || params.isActive === false) {
            if (ledCore) ledCore.setAttribute('fill', '#333');
            return;
          }

          // Update label
          if (labelEl && params.label) {
            labelEl.textContent = params.label;
          }

          // Handle blinking
          if (params.isBlinking && params.isOn) {
            // Stop existing blink interval to avoid multiple intervals
            if (svgElement.blinkInterval) {
              clearInterval(svgElement.blinkInterval);
              svgElement.blinkInterval = null;
            }

            // Create a new interval for this LED
            let on = true;
            svgElement.blinkInterval = setInterval(() => {
              if (ledCore) { // Check if element still exists
                ledCore.setAttribute('fill', on ? params.color : '#333');
                on = !on;
              } else {
                // If element was removed, stop interval
                clearInterval(svgElement.blinkInterval);
                svgElement.blinkInterval = null;
              }
            }, params.blinkRate || 500);
          } else {
            // Stop blinking
            if (svgElement.blinkInterval) {
              clearInterval(svgElement.blinkInterval);
              svgElement.blinkInterval = null;
            }
            // Set solid state
            ledCore.setAttribute('fill', params.isOn ? params.color : '#333');
          }
        }

        // Toggle LED function
        function toggleLED(svgElement) {
          const metadata = getMetadata(svgElement);
          if (metadata && metadata.parameters) {
            // Toggle the state
            metadata.parameters.isOn = !metadata.parameters.isOn;

            // Update metadata
            svgElement.querySelector('script[type="application/json"][class="metadata"]').textContent =
              JSON.stringify(metadata, null, 2);

            // Update appearance immediately
            updateLED(svgElement);
          }
        }

        // Initialize
        // Use this specific SVG instance, not a global query
        const svgElement = document.currentScript.closest('svg');
        if (svgElement && !svgElement.hasAttribute('data-led-initialized')) {
          svgElement.setAttribute('data-led-initialized', 'true');

          // Store a unique identifier for this LED
          svgElement.ledInstanceId = 'led-' + Math.random().toString(36).substr(2, 9);

          // Add click event listener to toggle LED
          const ledCore = svgElement.querySelector('.led-core');
          if (ledCore) {
            ledCore.addEventListener('click', function(e) {
              toggleLED(svgElement);
              e.stopPropagation(); // Prevent event bubbling
            });
          }

          // Initial update
          updateLED(svgElement);

          // Optional: listen for changes (if IDE overwrites metadata)
          // Simulate an "observer" - check for changes every 500ms
          svgElement.pollingInterval = setInterval(() => {
            // Safely check if element is still in DOM
            if (!svgElement.isConnected) {
              // Clean up if it's been removed
              if (svgElement.blinkInterval) clearInterval(svgElement.blinkInterval);
              if (svgElement.pollingInterval) clearInterval(svgElement.pollingInterval);
              return;
            }

            const metadata = getMetadata(svgElement);
            const params = metadata.parameters || {};

            // Initialize currentParams if needed
            if (!svgElement.currentParams) {
              svgElement.currentParams = {};
            }

            const currentColor = svgElement.currentParams.color;
            const isBlinking = svgElement.currentParams.isBlinking;
            const isOn = svgElement.currentParams.isOn;
            const isActive = svgElement.currentParams.isActive;

            if (params.color !== currentColor ||
                params.isBlinking !== isBlinking ||
                params.isOn !== isOn ||
                params.isActive !== isActive) {
              svgElement.currentParams = { ...params };
              updateLED(svgElement);
            }
          }, 500);

          // Cleanup on removal or unload
          function cleanupLED() {
            if (svgElement.blinkInterval) clearInterval(svgElement.blinkInterval);
            if (svgElement.pollingInterval) clearInterval(svgElement.pollingInterval);
          }

          window.addEventListener('beforeunload', cleanupLED);

          // For SVGs that are embedded and might be removed
          if (typeof MutationObserver === 'function') {
            try {
              const observer = new MutationObserver((mutations) => {
                mutations.forEach((mutation) => {
                  if (Array.from(mutation.removedNodes).some(node =>
                      node === svgElement || (node.contains && node.contains(svgElement)))) {
                    cleanupLED();
                    observer.disconnect();
                  }
                });
              });

              // Only observe if the SVG is in a document and has a parent node
              if (svgElement.parentNode) {
                observer.observe(svgElement.parentNode, { childList: true });
              }
            } catch (e) {
              // Ignore errors for standalone SVGs
              console.warn("Could not set up observer:", e);
            }
          }
        }
      })();
  ]]></script>
    </defs>
</svg>
