<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="400" height="200" viewBox="0 0 400 200">
    <title>Raspberry Pi Zero 2 W - Digital Twin</title>
    <desc>Interactive Raspberry Pi Zero 2 W with status indicators and port visualization</desc>

    <metadata>
        <component id="rpi-zero2w-001" name="Raspberry Pi Zero 2 W" type="rpi-zero2w">
            <parameters>
                <label>RPi Zero 2 W</label>
                <isPowered>true</isPowered>
                <cpuTemp>45.5</cpuTemp>
                <cpuLoad>25</cpuLoad>
                <isWifiConnected>true</isWifiConnected>
                <isBluetoothEnabled>false</isBluetoothEnabled>
                <usbOtgConnected>true</usbOtgConnected>
                <hdmiConnected>false</hdmiConnected>
                <cameraConnected>false</cameraConnected>
                <gpioActive>true</gpioActive>
            </parameters>
        </component>
    </metadata>

    <!-- PCB Board -->
    <rect class="pcb-board" x="50" y="30" width="300" height="130" rx="5" ry="5"
          fill="#0d6b0d" stroke="#095009" stroke-width="2"/>

    <!-- Board label -->
    <text class="board-label" x="200" y="20" font-size="14" text-anchor="middle" fill="#2c3e50">Raspberry Pi Zero 2 W</text>

    <!-- SoC (System on Chip) -->
    <rect class="soc" x="180" y="80" width="40" height="40" fill="#1a1a1a" stroke="#333" stroke-width="1"/>
    <text x="200" y="103" font-size="8" text-anchor="middle" fill="#666">RP3A0</text>

    <!-- Status LEDs -->
    <g class="status-leds">
        <!-- Power LED -->
        <circle class="power-led" cx="70" cy="50" r="3" fill="#27ae60"/>
        <text x="80" y="53" font-size="8" fill="#333">PWR</text>

        <!-- Activity LED -->
        <circle class="activity-led" cx="70" cy="65" r="3" fill="#e74c3c"/>
        <text x="80" y="68" font-size="8" fill="#333">ACT</text>
    </g>

    <!-- Mini HDMI Port -->
    <g transform="translate(60, 100)">
        <rect class="hdmi-port" x="0" y="0" width="25" height="15" fill="#666" stroke="#333" stroke-width="1"/>
        <text x="12" y="25" font-size="8" text-anchor="middle" fill="#333">miniHDMI</text>
        <circle class="hdmi-indicator" cx="12" cy="7" r="2" fill="#333"/>
    </g>

    <!-- USB OTG Port -->
    <g transform="translate(100, 100)">
        <rect class="usb-otg-port" x="0" y="0" width="20" height="15" fill="#666" stroke="#333" stroke-width="1"/>
        <text x="10" y="25" font-size="8" text-anchor="middle" fill="#333">USB</text>
        <circle class="usb-indicator" cx="10" cy="7" r="2" fill="#3498db"/>
    </g>

    <!-- Power USB Port -->
    <g transform="translate(140, 100)">
        <rect class="power-port" x="0" y="0" width="20" height="15" fill="#666" stroke="#333" stroke-width="1"/>
        <text x="10" y="25" font-size="8" text-anchor="middle" fill="#333">PWR</text>
        <circle class="pwr-indicator" cx="10" cy="7" r="2" fill="#27ae60"/>
    </g>

    <!-- Camera CSI connector -->
    <g transform="translate(250, 50)">
        <rect class="camera-connector" x="0" y="0" width="30" height="8" fill="#ecf0f1" stroke="#bdc3c7" stroke-width="1"/>
        <text x="15" y="18" font-size="8" text-anchor="middle" fill="#333">CAM</text>
        <circle class="cam-indicator" cx="15" cy="4" r="2" fill="#333"/>
    </g>

    <!-- MicroSD Card Slot -->
    <g transform="translate(290, 80)">
        <rect x="0" y="0" width="40" height="25" fill="#34495e" stroke="#2c3e50" stroke-width="1"/>
        <rect x="5" y="5" width="30" height="15" fill="#7f8c8d"/>
        <text x="20" y="35" font-size="8" text-anchor="middle" fill="#333">µSD</text>
    </g>

    <!-- GPIO Header (40 pin) -->
    <g transform="translate(60, 40)">
        <rect x="0" y="0" width="260" height="12" fill="#1a1a1a" stroke="#333" stroke-width="1"/>
        <!-- GPIO pins -->
        <g class="gpio-pins">
            <rect x="2" y="2" width="256" height="3" fill="#f39c12"/>
            <rect x="2" y="7" width="256" height="3" fill="#f39c12"/>
        </g>
        <text x="130" y="22" font-size="8" text-anchor="middle" fill="#333">GPIO 40-pin</text>
    </g>

    <!-- WiFi/BT Antenna -->
    <g transform="translate(300, 45)">
        <rect x="0" y="0" width="15" height="20" fill="#95a5a6" stroke="#7f8c8d" stroke-width="1"/>
        <circle class="wifi-indicator" cx="7" cy="10" r="3" fill="#3498db"/>
        <text x="7" y="30" font-size="8" text-anchor="middle" fill="#333">WiFi/BT</text>
    </g>

    <!-- Status display -->
    <g transform="translate(200, 140)">
        <text class="cpu-temp" x="0" y="0" font-size="10" text-anchor="middle" fill="#e74c3c">CPU: 45.5°C</text>
        <text class="cpu-load" x="0" y="15" font-size="10" text-anchor="middle" fill="#3498db">Load: 25%</text>
    </g>

    <defs>
        <!-- Internal SVG script -->
        <script><![CDATA[
        (function() {
            // Function to read metadata
            function getMetadata(svgElement) {
                const metadataElement = svgElement.querySelector('metadata component');
                if (metadataElement) {
                    try {
                        const parametersElement = metadataElement.querySelector('parameters');
                        if (parametersElement) {
                            const result = {
                                parameters: {
                                    label: parametersElement.querySelector('label')?.textContent || 'RPi Zero 2 W',
                                    isPowered: parametersElement.querySelector('isPowered')?.textContent === 'true',
                                    cpuTemp: parseFloat(parametersElement.querySelector('cpuTemp')?.textContent || '0'),
                                    cpuLoad: parseFloat(parametersElement.querySelector('cpuLoad')?.textContent || '0'),
                                    isWifiConnected: parametersElement.querySelector('isWifiConnected')?.textContent === 'true',
                                    isBluetoothEnabled: parametersElement.querySelector('isBluetoothEnabled')?.textContent === 'true',
                                    usbOtgConnected: parametersElement.querySelector('usbOtgConnected')?.textContent === 'true',
                                    hdmiConnected: parametersElement.querySelector('hdmiConnected')?.textContent === 'true',
                                    cameraConnected: parametersElement.querySelector('cameraConnected')?.textContent === 'true',
                                    gpioActive: parametersElement.querySelector('gpioActive')?.textContent === 'true'
                                }
                            };
                            return result;
                        }
                    } catch (e) {
                        console.warn('Error parsing metadata:', e);
                    }
                }
                return {};
            }

            // Function to update board appearance
            function updateBoard(svgElement) {
                const metadata = getMetadata(svgElement);
                const params = metadata.parameters || {};

                const powerLed = svgElement.querySelector('.power-led');
                const activityLed = svgElement.querySelector('.activity-led');
                const wifiIndicator = svgElement.querySelector('.wifi-indicator');
                const usbIndicator = svgElement.querySelector('.usb-indicator');
                const hdmiIndicator = svgElement.querySelector('.hdmi-indicator');
                const camIndicator = svgElement.querySelector('.cam-indicator');
                const pwrIndicator = svgElement.querySelector('.pwr-indicator');
                const cpuTempText = svgElement.querySelector('.cpu-temp');
                const cpuLoadText = svgElement.querySelector('.cpu-load');
                const gpioPins = svgElement.querySelector('.gpio-pins');

                // Update power LED
                if (powerLed) {
                    powerLed.setAttribute('fill', params.isPowered ? '#27ae60' : '#333');
                }

                // Update power indicator
                if (pwrIndicator) {
                    pwrIndicator.setAttribute('fill', params.isPowered ? '#27ae60' : '#333');
                }

                // Update activity LED (blink simulation)
                if (activityLed && params.isPowered) {
                    if (!svgElement.activityInterval) {
                        let on = true;
                        svgElement.activityInterval = setInterval(() => {
                            if (activityLed.isConnected) {
                                activityLed.setAttribute('fill', on ? '#e74c3c' : '#333');
                                on = !on;
                            } else {
                                clearInterval(svgElement.activityInterval);
                                svgElement.activityInterval = null;
                            }
                        }, params.cpuLoad > 50 ? 100 : 500);
                    }
                } else if (activityLed) {
                    if (svgElement.activityInterval) {
                        clearInterval(svgElement.activityInterval);
                        svgElement.activityInterval = null;
                    }
                    activityLed.setAttribute('fill', '#333');
                }

                // Update WiFi/BT indicator
                if (wifiIndicator) {
                    if (params.isWifiConnected) {
                        wifiIndicator.setAttribute('fill', '#3498db');
                    } else if (params.isBluetoothEnabled) {
                        wifiIndicator.setAttribute('fill', '#9b59b6');
                    } else {
                        wifiIndicator.setAttribute('fill', '#333');
                    }
                }

                // Update port indicators
                if (usbIndicator) {
                    usbIndicator.setAttribute('fill', params.usbOtgConnected ? '#3498db' : '#333');
                }
                if (hdmiIndicator) {
                    hdmiIndicator.setAttribute('fill', params.hdmiConnected ? '#f39c12' : '#333');
                }
                if (camIndicator) {
                    camIndicator.setAttribute('fill', params.cameraConnected ? '#e74c3c' : '#333');
                }

                // Update GPIO
                if (gpioPins) {
                    gpioPins.style.opacity = params.gpioActive ? '1' : '0.3';
                }

                // Update status display
                if (cpuTempText) {
                    cpuTempText.textContent = `CPU: ${params.cpuTemp.toFixed(1)}°C`;
                    // Change color based on temperature
                    if (params.cpuTemp > 70) {
                        cpuTempText.setAttribute('fill', '#e74c3c');
                    } else if (params.cpuTemp > 50) {
                        cpuTempText.setAttribute('fill', '#f39c12');
                    } else {
                        cpuTempText.setAttribute('fill', '#27ae60');
                    }
                }
                if (cpuLoadText) {
                    cpuLoadText.textContent = `Load: ${params.cpuLoad.toFixed(0)}%`;
                }
            }

            // Simulate CPU temperature and load
            function simulateSystem(svgElement) {
                const metadataElement = svgElement.querySelector('metadata component parameters');
                if (!metadataElement) return;

                const tempElement = metadataElement.querySelector('cpuTemp');
                const loadElement = metadataElement.querySelector('cpuLoad');

                if (tempElement && loadElement) {
                    let currentTemp = parseFloat(tempElement.textContent);
                    let currentLoad = parseFloat(loadElement.textContent);

                    // Simulate temperature based on load
                    const targetTemp = 35 + (currentLoad * 0.4);
                    currentTemp += (targetTemp - currentTemp) * 0.1;

                    // Simulate load changes
                    currentLoad += (Math.random() - 0.5) * 10;
                    currentLoad = Math.max(0, Math.min(100, currentLoad));

                    tempElement.textContent = currentTemp.toFixed(1);
                    loadElement.textContent = currentLoad.toFixed(0);
                }

                updateBoard(svgElement);
            }

            // Toggle connection states
            function toggleWifi(svgElement) {
                const metadataElement = svgElement.querySelector('metadata component parameters');
                if (metadataElement) {
                    const wifiElement = metadataElement.querySelector('isWifiConnected');
                    if (wifiElement) {
                        wifiElement.textContent = wifiElement.textContent === 'true' ? 'false' : 'true';
                        updateBoard(svgElement);
                    }
                }
            }

            // Initialize
            let svgElement = document.currentScript ? document.currentScript.closest('svg') : null;

            if (!svgElement) {
                const allSvgs = document.querySelectorAll('svg');
                for (const svg of allSvgs) {
                    if (svg.querySelector('.pcb-board') && svg.querySelector('.status-leds')) {
                        svgElement = svg;
                        break;
                    }
                }
            }

            if (svgElement && !svgElement.hasAttribute('data-rpi-zero2w-initialized')) {
                svgElement.setAttribute('data-rpi-zero2w-initialized', 'true');
                svgElement.rpiInstanceId = 'rpi-zero2w-' + Math.random().toString(36).substr(2, 9);

                // Add click event listeners
                const wifiIndicator = svgElement.querySelector('.wifi-indicator');
                if (wifiIndicator) {
                    wifiIndicator.addEventListener('click', function(e) {
                        toggleWifi(svgElement);
                        e.stopPropagation();
                    });
                    wifiIndicator.style.cursor = 'pointer';
                }

                // Initial update
                updateBoard(svgElement);

                // Start simulation
                svgElement.simulationInterval = setInterval(() => {
                    if (!svgElement.isConnected) {
                        if (svgElement.activityInterval) clearInterval(svgElement.activityInterval);
                        clearInterval(svgElement.simulationInterval);
                        return;
                    }
                    simulateSystem(svgElement);
                }, 2000);

                // Cleanup
                function cleanup() {
                    if (svgElement.simulationInterval) clearInterval(svgElement.simulationInterval);
                    if (svgElement.activityInterval) clearInterval(svgElement.activityInterval);
                }

                window.addEventListener('beforeunload', cleanup);
            }
        })();
        ]]></script>
    </defs>
</svg>
