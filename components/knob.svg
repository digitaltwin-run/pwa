<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xhtml="http://www.w3.org/1999/xhtml" width="40" height="40" viewBox="0 0 40 40" data-component-params="label,value,min,max,size,isactive,color,ison,isblinking,blinkrate">
    <title>Rotary Knob Component</title>
    <desc>Interactive rotary knob component with click animation for digital twin</desc>

    <metadata>
        <component id="knob-001" name="Rotary Knob" type="knob">
            <parameters>
                <label>Knob</label>
                <value>50</value>
                <min>0</min>
                <max>100</max>
                <size>40</size>
                <isActive>true</isActive>
            <color>#e74c3c</color><ison>false</ison><isblinking>false</isblinking><blinkrate>500</blinkrate></parameters>
        </component>
    </metadata>

    <!-- Base -->
    <circle class="knob-base" cx="20" cy="20" r="18" fill="#34495e" stroke="#2c3e50" stroke-width="1.5"/>
    <!-- Knob body -->
    <circle class="knob-body" cx="20" cy="20" r="14" fill="#7f8c8d" stroke="#2c3e50" stroke-width="1"/>
    <!-- Indicator line -->
    <line class="knob-indicator" x1="20" y1="20" x2="20" y2="9" stroke="#ecf0f1" stroke-width="2" stroke-linecap="round"/>
    <!-- Central dot -->
    <circle class="knob-center" cx="20" cy="20" r="3" fill="#2c3e50"/>
    <!-- Label -->
    <text class="knob-label" x="20" y="36" font-size="8" text-anchor="middle" fill="#bdc3c7">Knob</text>
    <!-- Value display -->
    <text class="knob-value" x="20" y="21" font-size="8" text-anchor="middle" fill="#ecf0f1">50</text>

    <defs>
        <script>
        <![CDATA[
        (function() {
          // Helper function to safely get element text content
          function getElementText(element, selector) {
            const el = element.querySelector(selector);
            return el ? el.textContent : null;
          }

          // Function to read metadata
          function getMetadata(svgElement) {
            const metadataElement = svgElement.querySelector('metadata component');
            if (!metadataElement) return { parameters: {} };

            try {
              const parametersElement = metadataElement.querySelector('parameters');
              if (!parametersElement) return { parameters: {} };

              return {
                parameters: {
                  label: getElementText(parametersElement, 'label') || 'Knob',
                  value: parseFloat(getElementText(parametersElement, 'value') || '50'),
                  min: parseFloat(getElementText(parametersElement, 'min') || '0'),
                  max: parseFloat(getElementText(parametersElement, 'max') || '100'),
                  color: getElementText(parametersElement, 'color') || '#2980b9',
                  size: parseFloat(getElementText(parametersElement, 'size') || '40'),
                  isActive: getElementText(parametersElement, 'isActive') === 'true'
                }
              };
            } catch (e) {
              console.warn('Error parsing metadata:', e);
              return { parameters: {} };
            }
          }

          // Function to update knob appearance and rotation
          function updateKnob(svgElement) {
            try {
              const metadata = getMetadata(svgElement);
              const params = metadata.parameters || {};

              const knobBody = svgElement.querySelector('.knob-body');
              const indicator = svgElement.querySelector('.knob-indicator');
              const labelEl = svgElement.querySelector('.knob-label');
              const valueEl = svgElement.querySelector('.knob-value');

              if (!knobBody || !indicator) return;

              if (!params.isActive) {
                knobBody.setAttribute('fill', '#555');
                return;
              }

              // Update label
              if (labelEl && params.label) {
                labelEl.textContent = params.label;
              }

              // Update knob body color
              if (params.color) {
                knobBody.setAttribute('fill', params.color);
              }

              // Calculate rotation angle based on value, min and max
              const min = typeof params.min === 'number' ? params.min : 0;
              const max = typeof params.max === 'number' ? params.max : 100;
              const value = Math.min(Math.max(parseFloat(params.value) || 50, min), max);
              const percentage = (value - min) / (max - min);
              const angle = percentage * 270 - 135; // -135° to +135° rotation

              // Apply rotation to indicator
              indicator.setAttribute('transform', 'rotate(' + angle + ' 20 20)');

              // Update value text
              if (valueEl) {
                valueEl.textContent = Math.round(value);
              }
            } catch (e) {
              console.error('Error updating knob:', e);
            }
          }

          // Function to update metadata value
          function updateMetadataValue(svgElement, newValue) {
            try {
              const valueElement = svgElement.querySelector('metadata component parameters value');
              if (valueElement) {
                valueElement.textContent = String(newValue);
                return true;
              }
            } catch (e) {
              console.error('Error updating metadata:', e);
            }
            return false;
          }

          // Initialize
          document.addEventListener('DOMContentLoaded', function() {
            // Initialize - bardziej odporna metoda znajdowania elementu SVG
            // Najpierw spróbuj standardową metodę (działa w IDE)
            let svgElement = document.currentScript ? document.currentScript.closest('svg') : null;

            // Jeśli nie znaleziono (np. w wyeksportowanym pliku), spróbuj znaleźć wszystkie SVG
            // i wybierz ten, który zawiera ten skrypt
            if (!svgElement) {
                // Pobierz wszystkie elementy SVG w dokumencie
                const allSvgs = document.querySelectorAll('svg');

                // Przeszukaj wszystkie SVG i znajdź ten z pokrętłem
                for (const svg of allSvgs) {
                    if (svg.querySelector('.knob-body') && svg.querySelector('.knob-indicator')) {
                        svgElement = svg;
                        break;
                    }
                }
            }

            if (!svgElement || svgElement.hasAttribute('data-knob-initialized')) {
              return;
            }

            svgElement.setAttribute('data-knob-initialized', 'true');

            // Store a unique identifier for this knob
            svgElement.knobInstanceId = 'knob-' + Math.random().toString(36).substr(2, 9);

            // Initial update
            updateKnob(svgElement);

            // Handle click interaction
            svgElement.addEventListener('click', function() {
              const knobBody = svgElement.querySelector('.knob-body');
              if (!knobBody) return;

              // Apply "pressed" effect animation
              knobBody.setAttribute('r', '12'); // Smaller size
              knobBody.setAttribute('fill-opacity', '0.8');

              // After a short delay, restore normal size
              setTimeout(function() {
                knobBody.setAttribute('r', '14');
                knobBody.setAttribute('fill-opacity', '1');

                // Get current metadata
                const metadata = getMetadata(svgElement);
                if (!metadata.parameters) return;

                // Increment value slightly for click
                const min = parseFloat(metadata.parameters.min) || 0;
                const max = parseFloat(metadata.parameters.max) || 100;
                let newValue = (parseFloat(metadata.parameters.value) || 50) + 5;
                if (newValue > max) newValue = min;

                // Update metadata
                updateMetadataValue(svgElement, newValue);

                // Update display
                updateKnob(svgElement);
              }, 150);
            });

            // Poll for changes
            const pollingInterval = setInterval(function() {
              try {
                // Check if element is still in DOM
                if (!document.body.contains(svgElement)) {
                  clearInterval(pollingInterval);
                  return;
                }

                updateKnob(svgElement);
              } catch (e) {
                console.error('Error in polling interval:', e);
                clearInterval(pollingInterval);
              }
            }, 500);

            // Store interval ID for cleanup
            svgElement.pollingInterval = pollingInterval;
          });
        })();
        ]]>
        </script>
    </defs>
</svg>