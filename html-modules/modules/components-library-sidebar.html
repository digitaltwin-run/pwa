<template id="components-library-sidebar-template">
<!-- Left Sidebar: Components Library -->
<aside class="sidebar left" id="components-library-sidebar">
    <div class="sidebar-header">
        <h3 class="sidebar-title">
            <span class="sidebar-icon">üîß</span>
            <span data-i18n="ui.components.title">Komponenty</span>
        </h3>

        <!-- Search and filters -->
        <div class="sidebar-controls">
            <input type="text" id="component-search" class="component-search"
                   data-i18n-placeholder="ui.components.search" placeholder="Szukaj komponent√≥w...">
            <select id="category-filter" class="category-filter">
                <option value="all" data-i18n="ui.components.categories.all">Wszystkie</option>
                <option value="Indicators" data-i18n="ui.components.categories.indicators">Wska≈∫niki</option>
                <option value="Actuators" data-i18n="ui.components.categories.actuators">Wykonywacze</option>
                <option value="Controls" data-i18n="ui.components.categories.controls">Kontrolery</option>
                <option value="Sensors" data-i18n="ui.components.categories.sensors">Sensory</option>
                <option value="Hardware" data-i18n="ui.components.categories.hardware">Sprzƒôt</option>
                <option value="Communication" data-i18n="ui.components.categories.communication">Komunikacja</option>
            </select>
        </div>
    </div>

    <div class="component-list" id="component-library">
        <!-- Components will be loaded dynamically -->
        <div class="loading" data-i18n="ui.components.loading">≈Åadowanie komponent√≥w...</div>
    </div>

    <div class="sidebar-footer">
        <div class="components-stats" id="components-stats">
            <span data-i18n="ui.components.total">≈ÅƒÖcznie:</span>
            <span id="components-count">0</span>
        </div>
    </div>

</aside>

<style>
/* Components Library Sidebar Styles */
.sidebar.left {
    width: 280px;
    background: #f8f9fa;
    border-right: 1px solid #dee2e6;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.sidebar-header {
    padding: 16px;
    border-bottom: 1px solid #e9ecef;
    background: white;
}

.sidebar-title {
    margin: 0 0 12px 0;
    font-size: 16px;
    font-weight: 600;
    color: #495057;
    display: flex;
    align-items: center;
    gap: 8px;
}

.sidebar-icon {
    font-size: 18px;
}

.sidebar-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.component-search, .category-filter {
    padding: 8px 12px;
    border: 1px solid #ced4da;
    border-radius: 4px;
    font-size: 13px;
    background: white;
}

.component-search:focus, .category-filter:focus {
    outline: none;
    border-color: #80bdff;
    box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

.component-list {
    flex: 1;
    overflow-y: auto;
    padding: 8px;
    background: #f8f9fa;
}

.loading, .error-state, .empty-state {
    text-align: center;
    padding: 32px 16px;
    color: #6c757d;
    font-size: 14px;
}

.error-state {
    color: #dc3545;
}

.component-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    margin-bottom: 4px;
    background: white;
    border: 1px solid #e9ecef;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.2s ease;
    user-select: none;
}

.component-item:hover {
    border-color: #007bff;
    box-shadow: 0 2px 4px rgba(0, 123, 255, 0.1);
    transform: translateY(-1px);
}

.component-item.selected {
    background: #e3f2fd;
    border-color: #2196f3;
}

.component-item.dragging {
    opacity: 0.5;
    transform: rotate(5deg);
}

.component-item-content {
    display: flex;
    align-items: center;
    gap: 10px;
    flex: 1;
    min-width: 0;
}

.component-icon {
    font-size: 18px;
    width: 24px;
    text-align: center;
    flex-shrink: 0;
}

.component-details {
    min-width: 0;
    flex: 1;
}

.component-name {
    font-size: 13px;
    font-weight: 500;
    color: #212529;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
    margin: 0;
}

.component-category {
    font-size: 11px;
    color: #6c757d;
    margin: 2px 0 0 0;
}

.component-actions {
    display: flex;
    gap: 4px;
    opacity: 0;
    transition: opacity 0.2s ease;
}

.component-item:hover .component-actions {
    opacity: 1;
}

.component-action {
    background: none;
    border: none;
    font-size: 14px;
    padding: 4px;
    border-radius: 3px;
    cursor: pointer;
    transition: background-color 0.2s ease;
}

.component-action:hover {
    background-color: rgba(0, 123, 255, 0.1);
}

.sidebar-footer {
    padding: 8px 16px;
    border-top: 1px solid #e9ecef;
    background: white;
}

.components-stats {
    font-size: 12px;
    color: #6c757d;
    text-align: center;
}

/* Categories styling */
.component-category-group {
    margin-bottom: 16px;
}

.category-header {
    font-size: 12px;
    font-weight: 600;
    color: #495057;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    padding: 8px 12px 4px 12px;
    background: #e9ecef;
    border-radius: 4px;
    margin-bottom: 4px;
}

/* Drag and drop visual feedback */
.drag-over {
    background: rgba(0, 123, 255, 0.1);
    border: 2px dashed #007bff;
}

/* Loading animation */
.loading::after {
    content: "";
    display: inline-block;
    width: 16px;
    height: 16px;
    border: 2px solid #dee2e6;
    border-radius: 50%;
    border-top-color: #007bff;
    animation: spin 1s linear infinite;
    margin-left: 8px;
}

/* SVG Loading animation */
.loading-svg {
    position: relative;
}

.loading-svg::after {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(255, 255, 255, 0.7);
    border-radius: 4px;
    display: flex;
    align-items: center;
    justify-content: center;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { opacity: 0.5; }
    50% { opacity: 0.8; }
    100% { opacity: 0.5; }
}

@keyframes spin {
    to {
        transform: rotate(360deg);
    }
}

/* Responsive design */
@media (max-width: 768px) {
    .sidebar.left {
        width: 100%;
        max-width: 320px;
    }

    .component-item {
        padding: 12px;
    }

    .component-name {
        font-size: 14px;
    }
}
</style>

<script type="module">
/**
 * Components Library Sidebar Module
 * Handles loading, display, and interaction with component templates
 */
class ComponentsLibrarySidebar {
    constructor() {
        // Use static components.json instead of API endpoint
        this.componentsJsonPath = '/components.json';
        this.components = [];
        this.filteredComponents = [];
        this.selectedCategory = 'all';
        this.searchQuery = '';

        // DOM elements
        this.sidebar = document.getElementById('components-library-sidebar');
        this.componentList = document.getElementById('component-library');
        this.searchInput = document.getElementById('component-search');
        this.categoryFilter = document.getElementById('category-filter');
        this.componentCount = document.getElementById('components-count');

        this.init();
    }

    async init() {
        console.log('üîß Initializing Components Library Sidebar...');

        this.setupEventListeners();
        await this.loadComponents();
        this.applyTranslations();

        console.log('‚úÖ Components Library Sidebar initialized');
    }

    setupEventListeners() {
        // Search functionality
        if (this.searchInput) {
            this.searchInput.addEventListener('input', (e) => {
                this.searchQuery = e.target.value.toLowerCase();
                this.filterAndRenderComponents();
            });
        }

        // Category filter
        if (this.categoryFilter) {
            this.categoryFilter.addEventListener('change', (e) => {
                this.selectedCategory = e.target.value;
                this.filterAndRenderComponents();
            });
        }

        // Listen for translation updates
        document.addEventListener('translationsLoaded', () => {
            this.applyTranslations();
        });
    }

    async loadComponents() {
        try {
            this.showLoading();

            console.log('üì¶ Loading components from static JSON file...');
            const response = await fetch(this.componentsJsonPath);

            if (!response.ok) {
                throw new Error(`Failed to load components.json: ${response.status}: ${response.statusText}`);
            }

            const data = await response.json();
            this.components = data.components || [];
            
            // Add default categories if not defined
            this.components.forEach(comp => {
                if (!comp.category) {
                    // Try to infer category from component ID or name
                    const id = comp.id?.toLowerCase() || '';
                    const name = comp.name?.toLowerCase() || '';
                    
                    if (id.includes('gauge') || id.includes('display') || name.includes('gauge') || name.includes('display')) {
                        comp.category = 'Indicators';
                    } else if (id.includes('valve') || id.includes('pump') || id.includes('motor') || 
                              name.includes('valve') || name.includes('pump') || name.includes('motor')) {
                        comp.category = 'Actuators';
                    } else if (id.includes('modbus') || id.includes('mqtt') || 
                              name.includes('modbus') || name.includes('rtu')) {
                        comp.category = 'Communication';
                    } else if (id.includes('sensor') || name.includes('sensor')) {
                        comp.category = 'Sensors';
                    } else {
                        comp.category = 'General';
                    }
                }
            });

            await this.filterAndRenderComponents();
            console.log(`‚úÖ Loaded ${this.components.length} components from static JSON file`);
            
        } catch (error) {
            console.error('‚ùå Failed to load components:', error);
            this.showError('Nie uda≈Ço siƒô za≈Çadowaƒá pliku komponent√≥w components.json.');
        }
    }

    async filterAndRenderComponents() {
        this.filteredComponents = this.components.filter(component => {
            // Category filter
            const categoryMatch = this.selectedCategory === 'all' || component.category === this.selectedCategory;

            // Search filter
            const searchMatch = !this.searchQuery ||
                component.name.toLowerCase().includes(this.searchQuery) ||
                component.category.toLowerCase().includes(this.searchQuery);

            return categoryMatch && searchMatch;
        });

        await this.renderComponents();
        this.updateComponentCount();
    }

    async renderComponents() {
        if (!this.componentList) return;

        if (this.filteredComponents.length === 0) {
            this.showEmpty();
            return;
        }

        // Group components by category
        const groupedComponents = this.groupComponentsByCategory(this.filteredComponents);

        // Show loading state while generating HTML
        this.showLoading();

        try {
            // Process each category and its components
            const categoryHTMLPromises = Object.entries(groupedComponents).map(async ([category, components]) => {
                // Generate header for the category if showing all categories
                const header = this.selectedCategory === 'all' ? 
                    `<div class="category-header">${this.translateCategory(category)}</div>` : '';
                
                // Generate component HTML items in parallel
                const componentPromises = components.map(component => 
                    this.createComponentItemHTML(component)
                );
                
                const componentItems = await Promise.all(componentPromises);
                return header + componentItems.join('');
            });
            
            // Wait for all category HTML to be generated
            const categoriesHTML = await Promise.all(categoryHTMLPromises);
            const html = categoriesHTML.join('');
            
            // Update the DOM
            this.componentList.innerHTML = html;
            this.attachComponentEvents();
            
        } catch (error) {
            console.error('Error rendering components:', error);
            this.showError('Problem z renderowaniem komponent√≥w');
        }
    }

    groupComponentsByCategory(components) {
        const grouped = {};
        components.forEach(component => {
            const category = component.category || 'General';
            if (!grouped[category]) {
                grouped[category] = [];
            }
            grouped[category].push(component);
        });
        return grouped;
    }

    async createComponentItemHTML(component) {
        const icon = await this.getComponentIcon(component.id);
        return `
            <div class="component-item"
                 data-component-id="${component.id}"
                 data-component-name="${component.name}"
                 data-svg-path="${component.svg}"
                 draggable="true">
                <div class="component-item-content">
                    <div class="component-icon">${icon}</div>
                    <div class="component-details">
                        <div class="component-name">${component.name}</div>
                        <div class="component-category">${this.translateCategory(component.category)}</div>
                    </div>
                </div>
                <div class="component-actions">
                    <button class="component-action" title="Dodaj do canvas" data-action="add">
                        ‚ûú
                    </button>
                    <button class="component-action" title="PodglƒÖd" data-action="preview">
                        üëÅÔ∏è
                    </button>
                </div>
            </div>
        `;
    }

    attachComponentEvents() {
        const componentItems = this.componentList.querySelectorAll('.component-item');

        componentItems.forEach(item => {
            // Click to add to canvas
            item.addEventListener('click', (e) => {
                if (e.target.closest('.component-action')) return;
                this.addComponentToCanvas(item);
            });

            // Drag and drop
            item.addEventListener('dragstart', (e) => {
                item.classList.add('dragging');
                e.dataTransfer.setData('text/plain', JSON.stringify({
                    id: item.dataset.componentId,
                    name: item.dataset.componentName,
                    svg: item.dataset.svgPath
                }));
            });

            item.addEventListener('dragend', () => {
                item.classList.remove('dragging');
            });

            // Action buttons
            const actions = item.querySelectorAll('.component-action');
            actions.forEach(action => {
                action.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const actionType = action.dataset.action;

                    if (actionType === 'add') {
                        this.addComponentToCanvas(item);
                    } else if (actionType === 'preview') {
                        this.previewComponent(item);
                    }
                });
            });
        });
    }

    addComponentToCanvas(item) {
        const componentData = {
            id: item.dataset.componentId,
            name: item.dataset.componentName,
            svg: item.dataset.svgPath
        };

        console.log('‚ûï Adding component to canvas:', componentData);

        // Dispatch custom event for canvas integration
        const event = new CustomEvent('add-component-to-canvas', {
            detail: componentData
        });
        document.dispatchEvent(event);

        // Show visual feedback
        item.style.transform = 'scale(0.95)';
        setTimeout(() => {
            item.style.transform = '';
        }, 200);

        // Show notification if available
        if (window.notificationSystem) {
            window.notificationSystem.showNotification(
                `Dodano komponent: ${componentData.name}`,
                'success',
                3000
            );
        }
    }

    async getComponentIcon(componentId) {
        // Set loading state for this component if it's already in the DOM
        // (only affects subsequent renders, not initial load)
        this.showSvgLoading(componentId);
        
        try {
            // Try to fetch SVG icon from /components directory
            const svgUrl = `/components/${componentId}.svg`;
            const response = await fetch(svgUrl);
            
            if (!response.ok) {
                throw new Error(`SVG not found: ${svgUrl}`);
            }
            
            // Parse SVG and prepare it as an icon
            const svgText = await response.text();
            const parser = new DOMParser();
            const svgDoc = parser.parseFromString(svgText, 'image/svg+xml');
            const svgElement = svgDoc.querySelector('svg');
            
            if (!svgElement) {
                throw new Error('Invalid SVG content');
            }
            
            // Ensure consistent size for icon display
            svgElement.setAttribute('width', '20');
            svgElement.setAttribute('height', '20');
            svgElement.setAttribute('viewBox', svgElement.getAttribute('viewBox') || '0 0 24 24');
            
            // Remove loading state
            this.hideSvgLoading(componentId);
            
            // Convert to string for use in HTML
            const serializer = new XMLSerializer();
            return serializer.serializeToString(svgElement);
            
        } catch (error) {
            console.warn(`Falling back to emoji icon for ${componentId}:`, error.message);
            this.hideSvgLoading(componentId);
            
            // Fallback to emoji icons
            const iconMap = {
                'gauge': 'üìä',
                'led': 'üí°',
                'pump': '‚öôÔ∏è',
                'valve': 'üîß',
                'motor': 'üîÑ',
                'tank': 'üõ¢Ô∏è',
                'display': 'üìü',
                'button': 'üîò',
                'slider': 'üéöÔ∏è',
                'graph': 'üìà',
                'label': 'üè∑Ô∏è',
                'switch': 'üîå',
                'panel': 'üìã',
                'indicator': 'üö•',
                'sensor': 'üå°Ô∏è'
            };
            
            return iconMap[componentId] || 'üîß';
        }
    }

    translateCategory(category) {
        const translations = {
            'Indicators': 'Wska≈∫niki',
            'Actuators': 'Wykonywacze',
            'Controls': 'Kontrolery',
            'Sensors': 'Sensory',
            'Hardware': 'Sprzƒôt',
            'Communication': 'Komunikacja',
            'General': 'Og√≥lne'
        };

        return translations[category] || category;
    }

    updateComponentCount() {
        if (this.componentCount) {
            this.componentCount.textContent = this.filteredComponents.length;
        }
    }

    showLoading() {
        if (this.componentList) {
            this.componentList.innerHTML = `
                <div class="loading" data-i18n="ui.components.loading">
                    ≈Åadowanie komponent√≥w...
                </div>
            `;
        }
    }

    showError(message) {
        if (this.componentList) {
            this.componentList.innerHTML = `
                <div class="error-state">
                    <div>‚ùå</div>
                    <div>${message}</div>
                    <button onclick="window.componentsLibrarySidebar.loadComponents()"
                            style="margin-top: 12px; padding: 6px 12px; border: 1px solid #dc3545; background: white; color: #dc3545; border-radius: 4px; cursor: pointer;">
                        Spr√≥buj ponownie
                    </button>
                </div>
            `;
        }
    }

    showEmpty() {
        const message = this.searchQuery
            ? `Nie znaleziono komponent√≥w dla "${this.searchQuery}"`
            : 'Brak komponent√≥w w wybranej kategorii';

        if (this.componentList) {
            this.componentList.innerHTML = `
                <div class="empty-state">
                    <div>üì¶</div>
                    <div>${message}</div>
                </div>
            `;
        }
    }

    applyTranslations() {
        // This will be called when translations are loaded
        // For now, we're using Polish as default
        console.log('üåê Applying translations to Components Library Sidebar');
    }

    // Public API methods
    refresh() {
        return this.loadComponents();
    }

    getComponentCount() {
        return this.components.length;
    }

    getFilteredCount() {
        return this.filteredComponents.length;
    }
}

// Initialize when DOM is loaded
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
        window.componentsLibrarySidebar = new ComponentsLibrarySidebar();
    });
} else {
    window.componentsLibrarySidebar = new ComponentsLibrarySidebar();
}

// Export for module usage
export default ComponentsLibrarySidebar;
</script>
</template>
